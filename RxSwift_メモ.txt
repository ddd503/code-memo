let disposeBag = DisposeBag()

struct Student {
    var score: BehaviorRelay<Int>
}

let people1 = Student(score: BehaviorRelay(value: 20))
let people2 = Student(score: BehaviorRelay(value: 40))
let people3 = Student(score: BehaviorRelay(value: 30))

let student = PublishSubject<Student>()

// flatMapLatestは購読後、別のオブザーバーに参照されたら、元の購読対象は外れる（同時購読対象は1つだけ）
student.asObservable()
    .flatMapLatest { $0.score.asObservable() }
    .subscribe(onNext: {
        print($0)
    }).disposed(by: disposeBag)

// 購読開始（開始から判定イベントは流れる）
student.onNext(people1)
student.onNext(people2) // people1の購読は外れる
student.onNext(people3) // people2の購読は外れる
// 以降は出力されない
people1.score.accept(50)
people2.score.accept(40)
people1.score.accept(55)
// 結果：20, 40, 30












let disposeBag = DisposeBag()

struct Student {
    var score: BehaviorRelay<Int>
}

let people1 = Student(score: BehaviorRelay(value: 75))
let people2 = Student(score: BehaviorRelay(value: 95))

let student = PublishSubject<Student>()

// flatMapとmap
student.asObservable()
    .flatMap { $0.score.asObservable() }
    .subscribe(onNext: {
        print($0)
    }).disposed(by: disposeBag)

// 購読開始（開始から判定イベントは流れる）
student.onNext(people1)
// 100点にした上で判定イベント
people1.score.accept(100)
// 購読開始（開始から判定イベントは流れる）
student.onNext(people2)

people2.score.accept(80)

people1.score.accept(50)










let disposeBag = DisposeBag()

// mapはイベント全てに共通の処理を施す
Observable.of(1, 2, 3, 4, 5)
    .map {
        return $0 * 2
   }.subscribe(onNext: {
        print($0)
   }).disposed(by: disposeBag)
// 結果：2, 4, 6, 8, 10






let disposeBag = DisposeBag()

// toArrayはイベントを１つの配列として扱う
Observable.of(1, 2, 3, 4, 5)
    .toArray().subscribe(onNext: {
        print($0)
    }).disposed(by: disposeBag)
// 結果：　[1, 2, 3, 4, 5]




subscribe(onNext: {})
なら非オプショナルで値がくる 

let strikes = PublishSubject<String>()

let disposeBag = DisposeBag()

// ignoreElements()は流した値を全て無視する
strikes
    .ignoreElements()
    .subscribe { _ in
    print("[Subscription is Called]")
}.disposed(by: disposeBag)

strikes.onNext("A")
strikes.onNext("B")
strikes.onNext("C")

strikes.onCompleted()



let strikes = PublishSubject<String>()

let disposeBag = DisposeBag()

// elementAt()は指定した値以上のeventが流れた時に初めて購読する
// 結果： Xが１つだけ出力される
strikes.elementAt(2)
    .subscribe(onNext: { text in
        print(text)
    }).disposed(by: disposeBag)

strikes.onNext("X")
strikes.onNext("X")
strikes.onNext("X")




let disposeBag = DisposeBag()

// filterは順番に取り出して、処理を施す（map的に使う）
Observable.of(1, 2, 3, 4, 5, 6, 7)
    .filter { $0 % 2 == 0 }
    .subscribe(onNext: {
        print($0)
    }).disposed(by: disposeBag)
// 結果：2, 4, 6




let disposeBag = DisposeBag()

// skip()は指定した数字の分だけ前の要素を無視して購読する
Observable.of("A", "B", "C", "D", "E", "F")
    .skip(3)
    .subscribe(onNext: {
        print($0)
    }).disposed(by: disposeBag)
// 結果：D, E, F





let disposeBag = DisposeBag()

// skipWhile {} は中で指定した条件から外れるまでskipを繰り返し、外れて以降は全て購読する
Observable.of(2, 2, 3, 4, 4).skipWhile { $0 % 2 == 0 }.subscribe(onNext: {
    print($0)
}).disposed(by: disposeBag)
// 結果：3, 4, 5







let disposeBag = DisposeBag()

let subject = PublishSubject<String>()
let trigger = PublishSubject<String>()

// skipUntil()は指定したオブジェクトが購読されるまで購読させない縛り(今回の$0はsubjectの方)
subject.skipUntil(trigger)
    .subscribe(onNext: {
        print($0)
    }).disposed(by: disposeBag)

subject.onNext("A")
subject.onNext("B")

trigger.onNext("X")

subject.onNext("C")

// 結果：C（A, Bは無視される）






let disposeBag = DisposeBag()

// take()は指定した数だけ先にきた値を購読して、それ以降は無視する
Observable.of(1, 2, 3, 4, 5, 6)
    .take(3)
    .subscribe(onNext: {
        print($0)
    }).disposed(by: disposeBag)
// 結果：1, 2, 3（4以降は無視）







let disposeBag = DisposeBag()

// takeWhile {} は中で指定した条件を満たすうちは購読を続け、満たさない要素がきた以降は購読しない
Observable.of(2, 4, 6, 7, 8, 10)
    .takeWhile { $0 % 2 == 0 }
    .subscribe(onNext: {
        print($0)
    }).disposed(by: disposeBag)
// 結果：2, 4, 6（7が満たさなかったから）







let disposeBag = DisposeBag()

let subject = PublishSubject<String>()
let trigger = PublishSubject<String>()

/// takeUntil()は中に指定したsubjectが購読されるまで自身の購読を続ける（triggerが購読されたらsubjectの購読は止まる）
subject.takeUntil(trigger)
    .subscribe(onNext: {
        print($0)
    }).disposed(by: disposeBag)

subject.onNext("1")
subject.onNext("2")

trigger.onNext("X")

subject.onNext("3")

// 結果：1, 2






通知系の購読登録
NotificationCenter.default.rx.notification(.AVCaptureSessionDidStartRunning)
            .subscribe(onNext: { [weak self] (_) in
                guard let self = self else { return }
                DispatchQueue.main.async {
                    self.buttonAreaView.setViewState(.shoot)
                }
            }).disposed(by: disposeBag)

        NotificationCenter.default.rx.notification(.NSManagedObjectContextDidSave)
            .subscribe(onNext: { [weak self] (_) in
                guard let self = self else { return }
                DispatchQueue.main.async {
                    // TODO: インジケータストップ
                    self.dismiss(animated: true)
                }
            }).disposed(by: disposeBag)



// AVCaptureSessionのisRunningをobservable（監視できる形）にする拡張
extension Reactive where Base: AVCaptureSession {
    var isRunning: Observable<Bool> {
        return observe(Bool.self, #keyPath(AVCaptureSession.isRunning))
            .flatMap { $0.flatMap { Observable.just($0) } ?? .empty() }
    }
}



// errorのときにデフォルト値を返す
.flatMap { value -> Observable<Int> in
    return Observable<Int>.error(NSError())
        .catchErrorJustReturn(1)
}

// errorのときに無視する
.flatMap { value -> Observable<Int> in
    return Observable<Int>.error(NSError())
        .catchError { error in
            return error
                .flatMap { _ inObservable<Int>.empty() }
        }
}

1回のonNext(value)の直後にonCompletedを発行します
Observable.just(1)

手順を数値で指定できる
let scheduler = TestScheduler(initialClock: 0)

1秒ごとに順に入力させている
let observable = scheduler.createHotObservable([
            Recorded.next(1, "R"),
            Recorded.next(2, "Rx"),
            Recorded.next(3, "RxS"),
            Recorded.next(4, "RxSw"),
            Recorded.next(5, "RxSwi"),
            Recorded.next(6, "RxSwift")
            ])

// 生成した手順をスタートする
scheduler.start()

printしてみる

_ = observable.subscribe(onNext: {
            print($0)
        })

結果
R
Rx
RxS
RxSw
RxSwi
RxSwift


debounceは指定の時間の間の処理を無視してくれる（TestSchedulerを用意して時間を測らせる）

func test_debounce() {
        let scheduler = TestScheduler(initialClock: 0)
        // 1秒ごとの手順を指定
        let observable = scheduler.createHotObservable([
            Recorded.next(1, "R"),
            Recorded.next(2, "Rx"),
            Recorded.next(3, "RxS"),
            Recorded.next(4, "RxSw"),
            Recorded.next(5, "RxSwi"),
            Recorded.next(6, "RxSwift")
            ])

        // 1秒以内変化は無視する条件付きでprint（結果、6番目の手順まで1秒以内の処理なので無視され、「RxSwift」しか出ない）
        _ = observable
            .debounce(.seconds(1), scheduler: scheduler)
            .subscribe(onNext: {
                print("onNext:", $0)
            })

        // 結果は「RxSwift」のみ
        scheduler.start()
    }



ストリーム（処理の流れ、監視）に対するオペレーター（処理条件を加える filterとか）がいる

オペレーター
orEmpty・・・nilが来たら空文字(非オプショナル)を入れてくれる

asObservable()・・・監視対象として確定

オペレーターとして使うには、戻り値がobservable属性を持ってないとだめ
つまり監視対象型の属性にしないとrxでは扱ってくれない（宣言的に書くゆえに型を把握しておきたいから）
どうするか　→ 一番単純なのは

.justで囲む　→  .just(10)
戻り値の書き方　＝　Observable<Int>

observable（監視される変数型）を作るときはletで良い（値の変化を購読するからnewではない）
let signupEnabled: Observable<Bool>

ui系を監視するときはbindを使う

validatedUsername(enum)の結果によってラベルの表示変える

bindのルール
同じ型にする（型通しが同じならbindで受け渡し可能！！）
・validatedUsername: 型 ＝　bind(to: 型)

viewModel.validatedUsername
            .bind(to: usernameValidationOutlet.rx.validationResult)
            .disposed(by: disposeBag)

// enumの結果をラベルに伝える
extension Reactive where Base: UILabel {
    var validationResult: Binder<ValidationResult> {
        return Binder(base) { label, result in
            label.textColor = result.textColor
            label.text = result.description
        }
    }
}


複数箇所から購読（subscribe）されるときはhot coolに気をつける
.share(replay: 1)でhotにする

coolだと一度の購読で複数箇所に情報を渡せない
複数分購読する

driver はUI用のobserver
・mainスレッドでレスポンスくる
・エラーは届かない
が確約

UI系のプロパティのobserveはdriver

hot ・・・保持する（購読対象が複数の場合はキャッシュを読んでくれるイメージ）
cold・・・保持しない（キャッシュを読んではダメなとき、ボタンのタップイベントとか結果自体を保持してはダメ）

長押しを購読
 let signinLongpress = signinButton.rx.controlEvent([.touchDown])
    signinLongpress
        .flatMapLatest { _ in
            Observable<Int64>.interval(3, scheduler: MainScheduler.instance)
                .take(1)
        }
        .subscribe(onNext:{ _ in print("do fun stuff only once when longpress detected")})
        .disposed(by: disposeBag)
