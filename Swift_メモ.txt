Swift コードメモ

Entityの削除
private func deleteAll() {
        let context = CoreDataDummyPropaties.shared.persistentContainer.viewContext
        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "Memo")
        let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)

        do {
            try context.execute(deleteRequest)
        } catch let error as NSError {
            print("error: \(error.localizedDescription)")
        }
    }

Alamofire 5.0以降（AFになる）
import Alamofire

enum APIRequestError: Error {
    case offline
}

final class APIClient {
    static func request(option: URLRequestConvertible, completionHandler: @escaping (Result<Data, Error>) -> ()) {
        guard onLineNetwork() else {
            completionHandler(.failure(APIRequestError.offline))
            return
        }

        AF.request(option).responseData { (responseData) in
            switch responseData.result {
            case .success(let data):
                completionHandler(.success(data))
            case .failure(let error):
                completionHandler(.failure(error))
            }
        }
    }

    static func onLineNetwork() -> Bool {
        if let reachabilityManager = NetworkReachabilityManager() {
            reachabilityManager.startListening()
            return reachabilityManager.isReachable
        }
        return false
    }
}




iOS13からpresentはハーフモーダルになった
fullScreenでpresentしたい時は、みたいな感じ

        cameraVC.modalPresentationStyle = .fullScreen
そして、ハーフモーダルの場合は,戻った時にviewwillapperが走らない、fullなら走る

Viewに影つける
影の長さ、width = +: 右、-: 左、height: +: 下方向、=: 上方向
 actionsView.layer.shadowOffset = CGSize(width: 0.0, height: -3.0)
影の色
actionsView.layer.shadowColor = UIColor.black.cgColor
影の濃さ
actionsView.layer.shadowOpacity = 0.2
影のぼかし度、ぼければ長くなる
actionsView.layer.shadowRadius = 8

ディレイかけて出して
    /// キャンセルボタンの非表示を切り替える
    private func setHiddenCancelButton(isHidden: Bool) {
        let delay: TimeInterval = isHidden ? 0.0 : 3.0
        let duration: TimeInterval = isHidden ? 0.3 : 0.3
        let alpha: CGFloat = isHidden ? 0.0 : 1.0
        isHidden ? view.sendSubviewToBack(cancelButton) : view.bringSubviewToFront(cancelButton)
        DispatchQueue.main.asyncAfter(deadline: .now() + delay) { [weak self] in
            UIView.animate(withDuration: duration, animations: {
                self?.cancelButton.alpha = alpha
            }, completion: { (_) in
                self?.cancelButton.isEnabled = !isHidden
            })
        }
    }


/// フェードインで表示後にフェードアウトで消える
    func fadeInToOut(fadeInDuration: TimeInterval, fadeOutDuration: TimeInterval, displayDuration: TimeInterval) {
        let totalDuration = fadeInDuration + fadeOutDuration + displayDuration
        let fadeInTime = TimeInterval(fadeInDuration / totalDuration)
        let fadeOutTime = TimeInterval(fadeOutDuration / totalDuration)
        UIView.animateKeyframes(withDuration: totalDuration, delay: 0.0, options: .init(), animations: { [weak self] in
            guard let self = self else { return }
            UIView.addKeyframe(withRelativeStartTime: 0.0, relativeDuration: fadeInTime, animations: {
                self.alpha = 1.0
            })
            UIView.addKeyframe(withRelativeStartTime: 1.0 - fadeOutTime, relativeDuration: fadeOutTime, animations: {
                self.alpha = 0.0
            })
        }) { [weak self] (_) in
            self?.removeFromSuperview()
        }
    }

照準でのsort配列
sorted { $0.key < $1.key }

UIImageViewのサブクラスでdrawが走らない
1

UIImageViewクラスは、ディスプレイに画像を描画するために最適化されています。UIImageViewは、そのサブクラスのdrawRect：メソッドを呼び出しません。サブクラスにカスタム描画コードを含める必要がある場合は、代わりにUIViewクラスをサブクラス化する必要があります。


 private func setupPanGesture() {
        let panGesture = UIPanGestureRecognizer(target: self, action: #selector(didPan(panGesture:)))
        materialImageView.addGestureRecognizer(panGesture)
    }



   /// Panアクションのハンドリング
    @objc private func didPan(panGesture: UIPanGestureRecognizer) {
        guard let panView = panGesture.view else { return }
        let location = panGesture.location(in: panView)
        switch panGesture.state {
        case .began:
            print(location)
        case .changed:
            print(location)
        case .ended:
            print(location)
        default: break
        }
    }

import UIKit

extension UIScrollView {
    /// 一番上までスクロールされているかどうか
    ///
    /// - Returns: Bool
    func isScrollToTop() -> Bool {
        return contentOffset.y <= 0
    }

    /// 一番上までスクロールする（なんか違っている！！！１１１）
    ///
    /// - Parameter animated: アニメーションをさせるか
    func scrollToTop(animated: Bool) {
        setContentOffset(CGPoint(x: 0, y: -(contentInset.top + adjustedContentInset.top)), animated: animated)
    }

    /// 一番下までスクロールする
    ///
    /// - Parameter animated: アニメーションをさせるか
    func scrollToBottom(animated: Bool) {
        setContentOffset(CGPoint(x: 0, y: contentSize.height - frame.height), animated: animated)
    }
}


coredata リレーションまたぎのfetch
NSPredicate(format: "personRel.idPerson == %@", person.idPerson)

collectionviewの横スクロールでsafeareaが邪魔する時
https://qiita.com/kazuhiro4949/items/1b362c3d987bda479490


// 渡したタスクをメインスレッドで実行する（パフォーマンスを考慮し、もともとメインの場合はスレッド操作は行わない）
    func executionMainThread(_ task: @escaping () -> ()) {
        if Thread.isMainThread {
            task()
        } else {
            DispatchQueue.main.async {
                task()
            }
        }
    }

「画面がタップされた時にそのPointを取得し、それが所定のRectの中に入っているかどうかを判定したい」という場合は~=演算子を次のようにオーバーロードします。

func ~= (rect:CGRect, point:CGPoint) -> Bool
{
    return ((rect.minX...rect.minX + rect.width) ~= point.x) && ((rect.minY...rect.minY + rect.height) ~= point.y)
}
使う時はこんなかんじ。

let point = (タップしたpoint)
let rect = (所定のrect)
switch point {
case rect:
    print("rectの中だよ！")
default:
    print("rectの外だよ！")
}



Double
print(floor(decimal)) // 3.0 (切り捨て)
print(ceil(decimal)) // 4.0 (切り上げ)
print(round(decimal)) // 3.0 (四捨五入)

マイグレーション設定
   // 自動マイグレーション設定（デフォルトでtrueだからいらない？）
        let description = NSPersistentStoreDescription()
        description.shouldMigrateStoreAutomatically = true
        description.shouldInferMappingModelAutomatically = true
        container.persistentStoreDescriptions = [description]


coredataのモデルが2つある問題

新しいビルド-Xcode 10.1 codegenがManual / Noneに設定されていなかったため、デフォルトではありません。派生データを取り込みますが、これは機能とは思えません。

 

動作が予想される場合でも、それはバグだと思います。通常のビルドが行われないようにします。codegenが変更されたときに選択されるプロセスを説明するドキュメントが見つかりません。

 

Manual / Noneがデフォルトだと思います。


上だけ枠線つける
        let borderLayer = CALayer()
        borderLayer.frame = CGRect(origin: .zero, size: CGSize(width: actionsView.frame.width, height: 0.1))
        borderLayer.backgroundColor = UIColor.lightGray.cgColor
        actionsView.layer.addSublayer(borderLayer)


画面全体以外のパターンでNVActivityIndicatorViewを使う時、ラベルとか自前で作った方がやりやすい

  private func setupIndicatorView() {
        indicatorView = NVActivityIndicatorView(frame: CGRect(origin: .zero, size: CGSize(width: 60, height: 60)))
        indicatorBaseView.addSubview(indicatorView)
        indicatorMessageLabel = UILabel(frame: .zero)
        indicatorMessageLabel.textAlignment = .center
        indicatorMessageLabel.font = .systemFont(ofSize: 15)
        indicatorMessageLabel.textColor = .white
        indicatorBaseView.addSubview(indicatorMessageLabel)
    }

///viewDidLayoutSubviews で
    private func adjustIndicatorPosition() {
        guard let image = materialImageView.image else { return }
        indicatorBaseView.frame = image.aspectFitFrame(imageView: materialImageView)
        let indicatorBaseViewCenter = indicatorBaseView.superview!.convert(indicatorBaseView.center, to: indicatorBaseView)
        indicatorView.center = indicatorBaseViewCenter
        indicatorMessageLabel.frame.size = CGSize(width: indicatorBaseView.frame.width * 0.7, height: 30)
        indicatorMessageLabel.center.x = indicatorBaseViewCenter.x
        indicatorMessageLabel.center.y = indicatorView.frame.maxY + 20
    }



storyboard側で作ったcustomViewをセットしたい（オーナーを自身でsubクラスは変えない）
final class ShutterButtonView: UIView {

    @IBOutlet weak private var shutterButton: UIButton!

    private var action: (() -> ())?

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        let view = UINib(nibName: "ShutterButtonView", bundle: nil).instantiate(withOwner: self, options: nil).first as! UIView
        addSubview(view)
    }

    override func layoutSubviews() {
        super.layoutSubviews()
        shutterButton.layer.masksToBounds = true
        shutterButton.layer.cornerRadius = shutterButton.bounds.width / 2
        shutterButton.setupTapAnimation()
        layer.masksToBounds = true
        layer.cornerRadius = bounds.width / 2
        layer.borderColor = shutterButton.backgroundColor?.cgColor
        layer.borderWidth = 6
        layoutIfNeeded()
    }

    @IBAction func didTapShutterButton(_ sender: UIButton) {
        action?()
    }

    func setButtonAction(action: @escaping () -> ()) {
        self.action = action
    }
}


xibでuiview作る（IB側のsuperViewのクラスをカスタムクラスにする、オーナーではない）
import UIKit

final class CanNotStartView: UIView {

    static func make(frame: CGRect) -> CanNotStartView {
        let view = UINib(nibName: "CanNotStartView", bundle: nil).instantiate(withOwner: nil, options: nil).first as! CanNotStartView
        view.frame = frame
        return view
    }

}


XcodeProjectテンプレートの作り方
https://www.google.co.jp/search?q=xcode+project+template&oq=xcode+project+template&aqs=chrome..69i57j0l5.12503j0j7&sourceid=chrome&ie=UTF-8


 /// キーボードが出た時にタップ位置が隠れるかどうか
    ///
    /// - Parameters:
    ///   - keyboardSize: キーボードのサイズ
    ///   - completion: 隠れるかどうか & 隠れた部分の長さ
    func isHiddenSelectPosition(keyboardSize: CGSize, completion: @escaping (_ isHedden: Bool, _ hiddenLength: CGFloat) -> ()) {
        let limit = UIScreen.main.bounds.height - keyboardSize.height
        currentCaretBottomY { (float) in
            let isHedden = float > limit
            let hiddenLength = float - limit
            completion(isHedden, hiddenLength)
        }
    }

 /// caretのbottomのY座標を取得する
    ///
    /// textViewDidBeginEditingで呼び出す
    func currentCaretBottomY(completion: @escaping (CGFloat) -> ()) {
        DispatchQueue.global().asyncAfter(deadline: .now() + 0.1) {
            DispatchQueue.main.async { [weak self] in
                guard let self = self, let selectedRange = self.selectedTextRange else { return }
                let caretRect = self.caretRect(for: selectedRange.start)
                let caretRectInWindow = self.convert(caretRect, to: nil)
                let caretBottomY = caretRectInWindow.origin.y + caretRectInWindow.size.height
                completion(caretBottomY)
            }
        }
    }

// TextViewの余白部分を取り除く　スペース　空白
let textView = UITextView(frame: view.bounds)
textView.textContinerInset = UIEdgeInsetsZero
textView.textContiner.lineFragmentPadding = 0
textView.layoutManager.useFontLeading = false
textView.sizeToFit()

 // 描画サイズを得る（useFontLeading抜き）
        let text = "ddd"
        let boundingRect = NSString(string: text).boundingRect(with: ラベルのcgsize,
                                                               options: [.usesLineFragmentOrigin],
                                                               attributes: [NSAttributeName: font],
                                                               context: nil)

// 描画サイズを得る（useFontLeading込み）
        let text = "ddd"
        let boundingRect = NSString(string: text).boundingRect(with: ラベルのcgsize,
                                                               options: [.usesLineFragmentOrigin, .UsesFontLeading],
                                                               attributes: [NSAttributeName: font],
                                                               context: nil)


CustomのViewクラス実装
import UIKit

class NotFoundWeatherInfoView: UIView {
    
    let task: (() -> ())

    init(frame: CGRect, task: @escaping () -> ()) {
        self.task = task
        super.init(frame: frame)
        let customView = Bundle.main.loadNibNamed("NotFoundWeatherInfoView", owner: self, options: nil)!.first! as! UIView
        addSubview(customView)
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    @IBAction func didTapRequest(_ sender: UIButton) {
        task()
    }
}


アラートやアクションシートをカスタムしたい時
UIPresentationController


UIViewController縛りのextension
extension TextViewKeyboardEventObservable where Self: UIViewController {}



switch内のreturnはその上のクロージャも出てしまう

カンマを３桁区切りでたす
extension Double {
    func addComma() -> String? {
        let number = NSNumber(value: self)
        let formatter = NumberFormatter()
        formatter.numberStyle = NumberFormatter.Style.decimal
        formatter.groupingSeparator = ","
        formatter.groupingSize = 3
        return formatter.string(from: number)
    }
}


private extension Date {
    var dateString: String {
        let format = DateFormatter()
        format.dateFormat = "yyyy-MM-dd" // 2019-09-07みたいな
        return format.string(from: self)
    }
}


TextViewのキャレット（選択しているところに出る縦棒）
/// キャレットの高さ調整
    override func caretRect(for position: UITextPosition) -> CGRect {
        var superRect = super.caretRect(for: position)
        guard let font = self.font else { return superRect }
        // キャレットの高さをフォントに合わせる
        superRect.size.height = font.pointSize - font.descender
        return superRect
    }



CIImageの向きをUIImageに揃える。帰る

extension CGImagePropertyOrientation {
    init(_ orientation: UIImage.Orientation) {
        switch orientation {
        case .up:
            self = .up
        case .down:
            self = .down
        case .left:
            self = .left
        case .right:
            self = .right
        case .upMirrored:
            self = .upMirrored
        case .downMirrored:
            self = .downMirrored
        case .leftMirrored:
            self = .leftMirrored
        case .rightMirrored:
            self = .rightMirrored
        default:
            self = .right
        }
    }
}


一番下までスクロールしているか
private func isBottomScroll() -> Bool {
        return contentSize.height <= (frame.height + contentOffset.y)
    }


func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        if text.contains(UIPasteboard.general.string ?? "") {
            print("コピペしたテキスト")
        }
        return true
    }


hugging: 伸びる
resistance: 耐える

extension String {
    /// 1行目のテキスト
    var firstLine: String {
        let lines = components(separatedBy: "\n")
        return lines.first ?? ""
    }

    /// 2行目以降のテキスト
    var afterSecondLine: String {
        var lines = components(separatedBy: "\n")
        guard lines.count > 1 else { return "" }
        // 1行目を削除
        lines.remove(at: 0)
        var text = lines.joined(separator: "\n")
        // 文末の改行を削除する
        text.removeLastIfNeeded(character: "\n", index: 1)
        return text
    }

    /// 特定の文字列が語尾の場合に文末を削除する
    ///
    /// - Parameters:
    ///   - character: この文字が語尾なら文末から文字列を削除する
    ///   - index: 文末から何文字削除するか
    mutating func removeLastIfNeeded(character: Character, index: Int) {
        guard let lastCharacter = self.last, lastCharacter == character else { return }
        removeLast(index)
    }
}


coredata orの検索
NSCompoundPredicate(orPredicateWithSubpredicates: [titlePredicate, contentsPredicate])


/// 1行目のテキスト
    var firstLine: String {
        let lines = components(separatedBy: "\n")
        return lines.first ?? ""
    }

    /// 2行目以降のテキスト
    var afterSecondLine: String {
        var lines = components(separatedBy: "\n")
        guard lines.count > 1 else { return "" }
        // 1行目を削除
        lines.remove(at: 0)
        var text = lines.joined(separator: "\n")
        // 文末の改行を削除する
        text.removeLastIfNeeded(character: "\n", index: 1)
        return text
    }

    /// 特定の文字列が語尾の場合に文末を削除する
    ///
    /// - Parameters:
    ///   - character: この文字が語尾なら文末から文字列を削除する
    ///   - index: 文末から何文字削除するか
    mutating func removeLastIfNeeded(character: Character, index: Int) {
        guard let lastCharacter = self.last, lastCharacter == character else { return }
        removeLast(index)
    }



navigationController?.presentはダメ

初期値にselfを使いたいときはlazy
 private let spacing: CGFloat = 20
    private lazy var insetForSection: () -> (UIEdgeInsets?) = { [weak self] in
        guard let self = self else { return nil }
        return UIEdgeInsets(top: self.spacing, left: self.spacing, bottom: 0, right: self.spacing)
    }
    private lazy var cellSize: () -> (CGSize?) = { [weak self] in
        guard let self = self else { return nil }
        let collectonViewSize = self.memoListView.frame.size
        return CGSize(width: collectonViewSize.width - self.spacing * 2,
                      height: collectonViewSize.height / 9)
    }


インクリメントサーチ　リアルタイム検索
 func searchBar(_ searchBar: UISearchBar, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        DispatchQueue.global().asyncAfter(deadline: .now() + 0.1) {
            /*
             文字入力許可後0.1秒後(入力許可後にsearchBar.textに文字が反映されている頃)に検索を開始する
             replacementTextには入力が確定していないので変換等が曖昧になっている(i → い)
             おそらくメインスレッドで呼ぶのが良い
             */
            DispatchQueue.main.async { [weak self] in
                self?.searchMemos(searchString: searchBar.text ?? "")
            }
        }
        return true
    }


UIAlertControllerは生成もメインスレッドで行う必要がある？(presentだけではなく)

    // 指定したrect部分のみのImageを返す（表示先のImageViewのcontentModeがaspectFitの場合限定）
    func croppingCaseAspectFit(rect: CGRect, imageView: UIImageView) -> UIImage? {
        let imageaAspectFitSize = aspectFitSize(imageViewBounds: imageView.bounds)
        let imageViewScale = max(imageaAspectFitSize.width * self.scale / imageView.frame.width,
                                 imageaAspectFitSize.height * self.scale / imageView.frame.height)
        let cropZone = CGRect(x: rect.origin.x * imageViewScale,
                              y: rect.origin.y * imageViewScale,
                              width: rect.size.width * imageViewScale,
                              height: rect.size.height * imageViewScale)
        guard let cgImage = self.cgImage, let cropImage = cgImage.cropping(to: cropZone) else {
            return nil
        }
        return UIImage(cgImage: cropImage, scale: self.scale, orientation: self.imageOrientation)
    }



配列の結合　改行を挟んで
let contents = sentenceArray.joined(separator: "\n")


画像からメモを作る
private func createMemo(selectedWordsRects: [CGRect], baseImageView: UIImageView) {

        guard !selectedWordsRects.isEmpty else {
            // TODO: 選択した文字列がなかった（本来はこの前の段階で潰す）
            return
        }

        guard let hollowOutImageView = hollowOutImageView(rects: selectedWordsRects,
                                                          imageView: baseImageView)  else {
                                                            // TODO: 文字列の読み取りに失敗アラートを出してOKで再スタート
                                                            return
        }

        guard let hollowOutImage = hollowOutImageView.image,
            let materialData = hollowOutImage.jpegData(compressionQuality: 1.0) else {
                // TODO: 文字列の読み取りに失敗アラートを出してOKで再スタート
                return
        }

        // TODO: インジケータスタート

        actionButtonAreaView.setViewState(.requestApi)
        viewModel.shouldSaveMemo = true
        
        viewModel.visionAPIDataStore.requestOCR(imageDataEncodedString: materialData.base64EncodedString()) { (result) in

            guard self.viewModel.shouldSaveMemo else { return }

            switch result {
            case .success(let jsonData):
                do {
                    let result = try JSONDecoder().decode(OCRResponse.self, from: jsonData)
                    // 検出した文字列をメモとして保存
                    result.responses.forEach({ [weak self] (annotateImageResponse) in
                        guard let self = self, let context = annotateImageResponse.memo.managedObjectContext else { return }

                        let memo = annotateImageResponse.memo
                        print(memo.contents ?? "")
                        // TODO: キャプチャのイメージデータをどのクラスで保持して、保存までつなげるか
                        // TODO: - クルクル回す（保存完了待ち）
                        self.viewModel.coreDataStore.save(context: context)
                    })
                } catch let error {
                    // TODO: jsonのパースに失敗した場合の処理
                    print(error.localizedDescription)
                }
            case .failure(let error):
                // TODO: 文字列の読み取りに失敗アラートを出してOKで再スタート
                print(error.localizedDescription)
            }
        }
    }

    /// ImageViewの指定の範囲を切り取って、白地Viewに貼って、その白地ViewのスクショをImageViewにして返す
    private func hollowOutImageView(rects: [CGRect], imageView: UIImageView) -> UIImageView? {
        guard let image = imageView.image else { return nil }

        let baseView = UIView(frame: image.aspectFitFrame(imageView: imageView))
        baseView.backgroundColor = .white

        rects.forEach {
            // baseViewから見た文字列の座標（imageViewではなくて）
            let rect = imageView.convert($0, to: baseView)
            guard let resizeImage = image.resize(baseView.frame.size),
                let cropImage = resizeImage.croppingCaseAspectFit(rect: rect, imageView: imageView) else {
                    return
            }
            let cropImageView = UIImageView(image: cropImage)
            cropImageView.frame = rect
            cropImageView.contentMode = imageView.contentMode
            baseView.addSubview(cropImageView)
        }

        guard let snapImage = baseView.snapImage() else { return nil }

        let imageView = UIImageView(image: snapImage)
        imageView.frame = baseView.frame
        imageView.contentMode = imageView.contentMode
        return imageView
    }



辞書型はmapすると出力順序が逆

経過時間
基準日時からの経過時間・残り時間
let calendar = Calendar.current
let dateFrom = calendar.date(from: DateComponents(year: 2010, month: 6, day: 10))!
let dateTo = calendar.date(from: DateComponents(year: 2011, month: 7, day: 11))!

var comps: DateComponents

// あと何秒か
comps = calendar.dateComponents([.second], from: dateFrom, to: dateTo)
print(comps.second!) // 34214400

// あと何日か
comps = calendar.dateComponents([.day], from: dateFrom, to: dateTo)
print(comps.day!) // 396

// あと何ヶ月と何日か
comps = calendar.dateComponents([.month, .day], from: dateFrom, to: dateTo)
print(comps.month!, comps.day!) // 13 1



 // rootVCまでdismissで戻る
        view.window?.rootViewController?.dismiss(animated: true, completion: nil)

mutating は自身に変更が入る場合のfuncにつける必要がある（stringの拡張で自分の文字列を削除する場合など）

initWithCoderとawakeFromNibの違い
initWithCoderでは、IBOutletやIBActionはロードされていない、awakeFromNibはロードされた後に呼び出される

photosのfetchは基本同期的なメソッド

PHAssetのenumerateObjects
並列で行うには、引数のoptionsに「並列」concurrentなどの指定を入れる


ナビバーの左上に戻るボタン
let leftBarButton = UIBarButtonItem(title: "閉じる", style: .plain, target: self, action: #selector(dismiss(sender:)))
        navigationItem.leftBarButtonItem = leftBarButton

@objc func dismiss(sender: UIBarButtonItem) {
        dismiss(animated: true, completion: nil)
    }

UITableViewの特定のセルを選択不可にする
この設定にはいくつかパターンがある。

Storyboard上ではUITableViewCellのSelectionの項目をNoneにする。




                // 三角部分の色
                context.setFillColor(color.cgColor)
        
                // 三角形の各頂点を取得
                let cornerPoints = directionType.triangleCornerPoints(superViewRect: rect,
                                                                      triangleBottomLength: triangleBottomLength,
                                                                      triangleHeight: triangleHeight)
                // 開始点を指定
                context.move(to: cornerPoints.top)
                // 移動点から二点以上指定して線を引かないと領域の確保がされずに短形は描画されない
                context.addLine(to: cornerPoints.left)
                context.addLine(to: cornerPoints.right)
                // 描画開始
                context.fillPath()



吹き出しの三角形部分を描画する

// 三角形の各頂点を取得
        let cornerPoints = directionType.triangleCornerPoints(superViewRect: rect,
                                                              triangleBottomLength: triangleBottomLength,
                                                              triangleHeight: triangleHeight)
  // 三角形の描画
        let triangle = UIBezierPath()
        triangle.move(to: cornerPoints.left)
        triangle.addLine(to: cornerPoints.top)
        triangle.addLine(to: cornerPoints.right)
        triangle.close()
        // 内側の色をセット
        color.setFill()
        // 内側を塗りつぶす
        triangle.fill()
        // 線の色をセット
        borderLineColor.setStroke()
        // 線の太さをセット
        triangle.lineWidth = borderLineWidth
        // 枠線を引く
        triangle.stroke()


innerViewからみたinnerViewのcenter（innnerのcenterに配置したかったから）
 self.convert(innerView.center, to: innerView)


override func draw(_ rect: CGRect)
ではrectが確定予定、frameはまだ変わってない

collectionViewのレイアウト（横2縦たくさんの間10間隔）
private let spacing: CGFloat = 10
    private lazy var insetForSection: () -> (UIEdgeInsets?) = { [weak self] in
        guard let self = self else { return nil }
        let inset = self.spacing * 2
        return UIEdgeInsets(top: self.spacing * 2, left: self.spacing * 2, bottom: 0, right: self.spacing * 2)
    }
    private lazy var cellSize: () -> (CGSize?) = { [weak self] in
        guard let self = self else { return nil }
        let collectonViewSize = self.memoListView.frame.size
        return CGSize(width: collectonViewSize.width / 2 - self.spacing * 3,
                      height: collectonViewSize.height / 10)
    }

extension MemoListViewController: UICollectionViewDelegateFlowLayout {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        return cellSize() ?? .zero
    }
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {
        return insetForSection() ?? .zero
    }
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        return spacing * 2
    }
}





レイヤー、角丸、丸角
layer.masksToBounds
layer.cornerRadius


ナビバーのスタイルを変える（色は自由にできないが、ステータスバーの色まで調整してくれる）
navigationController.navigationBar.barStyle = .black

ナビバーの色を変える
navigationController.navigationBar.barTintColor = .black

 // UIImageへの変換
    var image: UIImage {
        let renderer = UIGraphicsImageRenderer(bounds: bounds)
        return renderer.image { rendererContext in
            layer.render(in: rendererContext.cgContext)
        }
    }


extension UIView {
    // UIImageへの変換（スクリーンショット）
    func snapImage() -> UIImage? {
        defer { UIGraphicsEndImageContext() }
        UIGraphicsBeginImageContextWithOptions(frame.size, true, 0.0)
        guard let context = UIGraphicsGetCurrentContext() else { return  nil }
        layer.render(in: context)
        return UIGraphicsGetImageFromCurrentImageContext()
    }
}



coredataの検索条件（predicate）

 // isHiddenがtrueでないもののみ取得（削除していないもの）
let predicate = NSPredicate(format: "isHidden != %@", NSNumber(booleanLiteral: true))
fetchRequest.predicate = predicate

core data entity作成　エラー
used twice
https://stackoverflow.com/questions/38190360/duplicate-files-in-deriveddata-folder-using-coredata-generator

animationはcurveEaseInが自然な動きoutは不自然

配列の前から任意の個数取り出す
let points = displayButtons.enumerated().compactMap { $0.offset < maxButtonCount ? $0.element : nil}




任意の四辺に枠線をつける（どの辺かだけもいける）
let outline = CALayer()
        outline.frame = CGRect(origin: .zero, size: wordView.frame.size)
        outline.borderWidth = 2.0
        outline.borderColor = UIColor.red.cgColor
view.layer.addSublayer(outline)

四辺全てならCALayerを作らなくてもいい（親のlayerをいじるか、作ったlayerを乗せるかの違い）


変形で0にしたら、消さないと他に影響ある
testView.transform = CGAffineTransform(scaleX: 0.0, y: 0.0)
testView.alpha = 0

AVFoundation


   向きを固定ではなく、画面の向きに合わせて変化させたいときは、
        if let connection = layer.connection, connection.isVideoOrientationSupported,

            let orientation = AVCaptureVideoOrientation(rawValue: UIApplication.shared.statusBarOrientation.rawValue) {
            connection.videoOrientation = orientation

        }


  // AVCaptureMetadataOutputを用意（かめらViewで撮った画像をメタデータとして受け取るときに必要）
        let metadataOutput = AVCaptureMetadataOutput()
        guard captureSession.canAddOutput(metadataOutput) else { return }
        // セッションにセットして効果をはっき
        captureSession.addOutput(metadataOutput)
        metadataOutput.setMetadataObjectsDelegate(self, queue: .main)
        metadataOutput.metadataObjectTypes = viewModel.outputs.metadataObjectTypes


  // 最高の解像度を返すにはDeviceのhighResolutionStillImageDimensionsを設定する必要あり
//        settings.isHighResolutionPhotoEnabled = true


クロージャーで同じスレッドなのに、非同期っぽくなんか返すタイミングで迷ったら、returnをハンドラーにしちゃう

キーボード入力側で入力不可能な文字列が入っていないか trueなら入っている
username.rangeOfCharacter(from: CharacterSet.alphanumerics.inverted) != nil 

init内でselfを使う時はsuper.init()を呼んだ後で！

カスタムトランジションの画像のaspect値気をつける

         statusbarのisHidden状態を反映
        presenting.view.layoutSubviews()


// 遷移元のイメージビューのスクショを撮る
        let snapshot = fromVC.imageView.snapshotView(afterScreenUpdates: false)
        // 遷移元のイメージビューのフレームを取得
        snapshot?.frame = CGRect(x: 0, y: 0, width: fromVC.imageView.frame.width, height: fromVC.imageView.frame.height)

extension CollectionViewController: UICollectionViewDelegateFlowLayout {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        let length = collectionView.frame.size.width / 3
        return CGSize(width: length, height: length)
    }
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {
        return 0 // デフォルトは10だから明示的に指定する(storyboard側で変えてもいい)
    }
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        return 0 // デフォルトは10だから明示的に指定する(storyboard側で変えてもいい)
    }
}

let referenceDateString = "0000/00/00 00:00:00"

func createReferenceDate(dateString: String) -> Date? {
    let dateFormater = DateFormatter()
    dateFormater.locale = Locale(identifier: "ja_JP")
    dateFormater.dateFormat = "yyyy/MM/dd HH:mm:ss"
    return dateFormater.date(from: dateString)
}

// ランダムに指定の日より将来の日付を生成
func generateRandomFeatureDate(daysBack: Int, referenceDate: Date)-> Date {
    let day = arc4random_uniform(UInt32(daysBack))
    let hour = arc4random_uniform(23)
    let minute = arc4random_uniform(59)

    let gregorian  = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian)
    var offsetComponents = DateComponents()
    offsetComponents.day = Int(day) + 1
    offsetComponents.hour = Int(hour)
    offsetComponents.minute = Int(minute)

    let randomDate = gregorian?.date(byAdding: offsetComponents, to: referenceDate, options: .init(rawValue: 0) )
    return randomDate!
}

generateRandomFeatureDate(daysBack: 1,
                          referenceDate: createReferenceDate(dateString: referenceDateString)!)

// ランダムに指定の日より過去の日付を生成
func generateRandomPastDate(daysBack: Int, referenceDate: Date)-> Date {
    let day = arc4random_uniform(UInt32(daysBack))
    let hour = arc4random_uniform(23)
    let minute = arc4random_uniform(59)

    let gregorian  = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian)
    var offsetComponents = DateComponents()
    offsetComponents.day = -(Int(day) + 1)
    offsetComponents.hour = -(Int(hour))
    offsetComponents.minute = -(Int(minute))

    let randomDate = gregorian?.date(byAdding: offsetComponents, to: referenceDate, options: .init(rawValue: 0) )
    return randomDate!
}

generateRandomPastDate(daysBack: 1,
                       referenceDate: createReferenceDate(dateString: referenceDateString)!)


func ddd(count: (one: Int, two: Int),
         reference: (one: (over: Int, under: Int), two: (over: Int, under: Int)),
         referenceDateString: String) {
    forRandomDays(count: count.one, reference: reference.one, referenceDateString: referenceDateString)
    print("------------")
    forRandomDays(count: count.two, reference: reference.two, referenceDateString: referenceDateString)
}

func forRandomDays(count: Int, reference: (over: Int, under: Int), referenceDateString: String) {
    let featureDays = (0..<reference.over).map { _ in
        generateRandomFeatureDate(daysBack: 1000,
                                  referenceDate: createReferenceDate(dateString: referenceDateString)!)
    }
    let pastDays = (0..<reference.under).map { _ in
        generateRandomPastDate(daysBack: 1000,
                               referenceDate: createReferenceDate(dateString: referenceDateString)!)
    }

    print(featureDays.count)
    print(featureDays)
    print(pastDays.count)
    print(pastDays)
}

ddd(count: (one: 10, two: 2),
    reference: (one: (over: 8, under: 2), two: (over: 1, under: 1)),
    referenceDateString: referenceDateString)




 // ナビバー分のoffsetを自動調節
        photoListView.contentInsetAdjustmentBehavior = .always


swift4のKVO
プロパティでobserverが保持されていれば、監視を続ける（add removeいらない）
var photoListViewContentOffsetObserver: NSKeyValueObservation?

photoListViewContentOffsetObserver = photoListView.observe(\.contentOffset, options: [.new, .old]) { (_, value) in
            print(value)
        }



タイマー（連続実行）
// スタート
        autoScrollTimer = Timer.scheduledTimer(withTimeInterval: 2, repeats: true, block: { (timer) in
            print("インターバルごとのタスク実行")
        })

        // ストップ
        autoScrollTimer.invalidate()


絶対値（Int）
let x = -20
print(abs(x)) // 20

絶対値（Double, Float）
let y = -3.14
print(fabs(y)) // 3.14
整数では abs(整数), 少数では fabs(少数)。

配列でoffsetが持てる(enumeratedを使う)
indexs.enumerated().forEach

アラートアクションを外から渡す
メソッド
private func showAllItems(action: UIAlertAction)

渡すとき
actionHandler: showAllItems

カスタムのXibを取得（インスタンス化）
class func make() -> FinishView {
        let view = UINib(nibName: String(describing: FinishView.self), bundle: .main).instantiate(withOwner: self, options: nil).first as! FinishView
        return view
    }

テストはモッククラスで使いたい値はprotoclに定義して抽象化しておく

private extension String {

    // URLとしての形式、有効性に問題があった場合はnilを返す
    var formalUrl: URL? {
        guard let url = URL(string: self) else { return nil }
        return UIApplication.shared.canOpenURL(url) ? url : nil
    }

}

let scaleTransform = CGAffineTransform(scaleX: 1.0, y: diffarence)
let translationTransform = CGAffineTransform(translationX: 0, y: transition.y)
// 移動と伸縮を同時にやる
baseView.transform = scaleTransform.concatenating(translationTransform)


collectionViewのinsets込みのwidth（レイアウトのサブクラスで使う）
private var contentWidth: CGFloat {
        guard let collectionView = collectionView else { return 0 }
        let insets = collectionView.contentInset
        return collectionView.bounds.width - (insets.left + insets.right)
    }


乱数生成　ランダム　swift 4.2 以降
// 1から10までのIntを生成
let iValue = Int.random(in: 1 ... 10)
print(iValue)
 
// 1から3未満のFloatを生成
let fValue = Float.random(in: 1 ..< 3)
print(fValue)


SafeAreaを持っているか
private func hasSafeArea() -> Bool {
        let insets = UIApplication.shared.keyWindow?.safeAreaInsets ?? UIEdgeInsets.zero
        return ((insets.top > 0) && (insets.bottom > 0)) || ((insets.left > 0) && (insets.right > 0))
    }

lazyつければ、他のpropaty参照できる（格納型として保持するので注意、ない(nil)場合はreturnで返す）
private lazy var cellPadding = { () -> CGFloat in
        switch self.currentLayoutType {
        case .pintarest:
            return 5
        default:
            return 1
        }
    }()


UICollectionViewFlowLayoutのサイズ指定のいろいろ
テーブルビュー 的なやつ
        let ddd = CGSize(width: cv.bounds.inset(by: cv.layoutMargins).size.width, height: 70)
        itemSize = ddd
テーブルビュー 的なやつで横レイアウトの時は２列になる
 let avWidth = cv.bounds.inset(by: cv.layoutMargins).size.width
        let min = CGFloat(300)
        let max = Int(avWidth / min)
        let length = (avWidth / CGFloat(max)).rounded(.down)
        itemSize = CGSize(width: length, height: 70)




出ているVCの先頭は

private func isPresentedDetailQRCodeView() -> Bool {
        return self.presentedViewController as? DetailQRCodeViewController != nil
    }


親以外のViewからみた座標を取得する（中心座標など）
親View.convert(座標を取得したい子View, to: 親View以外のView（このViewからみた座標）)
（super→view1→subview）でsubviewの座標を決めるときは
view.convert(subviewのframe, to: view1)


viewの中のcardViewの座標を取得（親から見ないと正確な位置が取れない）
view.convert(cardView.frame, to: view).width

stackViewは内側(子View)の制約を最優先にして大きさを変える（自身が外と制約が付いていても）

extension内ではstoredプロパティ(格納型)は定義できないcomputedプロパティ(計算型)のみ

lazyのreturnは初期値と言うだけで値は保持される
private lazy var imageCachingManager = {
        return PHCachingImageManager()
    }()

microvcでcellを作るときは各セルvcのviewDidLoadは使い回しのセル分しか走らない（最初の７〜８めまでくらい）
なので、必須プロパティのdidSetを更新、リセットの起点とする

plistからのデータ取得
 guard let filePath = Bundle.main.path(forResource: "AreaDataList", ofType:"plist"), let listData = NSDictionary(contentsOfFile: filePath) else { fatalError() }
        print(listData)

enumの個別ケース比較はif caseのマッチパターンでできる
if case .pullToRefresh = type { endPullToRefresh() }


配列に配列をつなげる
append(contentsOf: [newValue])

switch文で複数条件での判定ができる

switch (Bool1, Bool2) {
case (true, false):

case (true, _):

case (false, true):

case (false, false):
}

シングルトン
static let shared = クラス　で持って
initはprivateにする

アプリの設定を開く
guard let settingsUrl = URL(string: UIApplication.openSettingsURLString) else { return }
        if UIApplication.shared.canOpenURL(settingsUrl) {
            UIApplication.shared.open(settingsUrl, options: [:], completionHandler: nil)
        }

ボタンのタイトルを変えるのは        
button.setTitle(model.buttonTitle, for: .normal)


ターゲットiOS11からXCAsset for Colorsの使用ができる
Assetsファイルで色を管理できるため、名前で引っ張れる、storyボードでも使える


// 並列キュー / attribute指定あり(.concurrent）
let dispatchQueue = DispatchQueue(label: "queue", attributes: .concurrent)

// 直列キュー / attibutes指定なし
let dispatchQueue = DispatchQueue(label: "queue")

git 打ち消し線
~~ここが打消しされるよ~~

DispatchQueueの使い方
種類について（一部）
直列、メインスレッド
let queue = DispatchQueue.main
直列、サブスレッド
let queue = DispatchQueue(label: "jp.sample.queue")
並列、サブスレッド
let queue = DispatchQueue.global(qos: .default)
let queue = DispatchQueue(label: "jp.sample.queue", attributes: .concurrent)

正規表現でのパターンマッチ判定
public func isMatch(pattern: String) -> Bool {
        guard let expression = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) else { return false }
        let range = NSRange(location: 0, length: self.count)
        let mathes = expression.matches(in: self, options: .anchored, range: range)
        return mathes.count > 0
        
使用例
if string.isMatch(pattern: "[a-zA-Z0-9]+://") {}



正規表現でのパターンマッチングを管理するenum

enum Pattern: Int, CaseIterable {
    case scheme
    
    func match(string: String) -> [String] {
        let objcString = string as NSString
        let range = NSRange(location: 0, length: objcString.length)
        let expression = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)
        let matches = expression?.matches(
            in: string,
            options: .withoutAnchoringBounds,
            range: range
        )
        return matches?.compactMap({ return objcString.substring(with: $0.range) }) ?? []
    }
    
    private var pattern: String {
        switch self {
        case .scheme: return "[a-zA-Z0-9]+://[^ \\n]+"
        }
    }
    
}


文字列の前後の空白と改行を削除
word?.trimmingCharacters(in: .whitespacesAndNewlines)




extension String {
    /// 指定文字列を文章内から取り除く
    ///
    /// - Parameter text: 取り除く文字列
    /// - Returns: 処理結果
    func trim(text: String) -> String {
        return self.replacingOccurrences(of: text, with: "", options: .literal, range: nil)
    }
}


struct PhotoLibraryEntityをExtensionで子プロパティを定義する
（ネストを減らす）



tableviewの縦に動いた瞬間に横のスクロールをとる（visible,見えているテーブルビューの開始時）

XcodeProjectテンプレートの作り方

protcolはその人にしか、つけられないようにする（）




戻り値使わない
@discardableResult


UIColorカラーリテラル
#colorLiteral(red: 0.4274509804, green: 0.7568627451, blue: 0.6196078431, alpha: 1)


ステータスバー　statusbarの色変える（VCごとに設定）
 override var preferredStatusBarStyle: UIStatusBarStyle {
        return .lightContent
    }

BlurViewの単体は単純に曇りガラス
BlurViewのエフェクト付きの方はBlurの中のViewを透明などブラーに合わせた見た目に勝手に調整してくれる


fetchControllerのセクションとせる
セクションごとのオブジェクトの数
fetchController.sections![0].numberOfObjects
セクションごとのオブジェクト
fetchController.sections![0].objects


tableview in collection view
tableviewcell 内の collection view をstackviewで囲むとcell生成メソッドが走らない

アニメーションデリゲート（コントローラー側）
extension ListViewController: UIViewControllerTransitioningDelegate {
    
    func animationController(forPresented presented: UIViewController,
                             presenting: UIViewController,
                             source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        return CustomAnimator(duration: 0.5, isPresenting: true)
    }
    
    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        return CustomAnimator(duration: 0.5, isPresenting: false)
    }

}

２つのプロトコル準拠
Decodable & Encodable


codable準拠のstructでパースするプロパティを制限できる
struct Person: Codable { 
    var firstName: String 
    var lastName: String 
    var nickname: String? 
　　　
　　　ここの2つだけパースする
    private enum CodingKeys: String, CodingKey { 
     case firstName
     case lastName 
    } 
} 

画像ファイルの種類によって、ツールバーに入るボタンを動的に設定している（ボタン自体はストーリーボードの画面外にセットしてある）
if asset.mediaType == .video {
            toolbarItems = [favoriteButton, space, playButton, space, trashButton]
        } else {
            // In iOS, present both stills and Live Photos the same way, because
            // PHLivePhotoView provides the same gesture-based UI as in the Photos app.
            toolbarItems = [favoriteButton, space, trashButton]
        }
ツールバーのボタンの動的切り替え
https://qiita.com/_ha1f/items/6ae8ece70107f2944a78


navigationVCの子VCにてViewタッチでナビバーを閉じるアニメーション設定（viewのsubviewで別のタッチイベントがあるとそちらが優先される）
navigationController?.hidesBarsOnTap = true


ナビバーの表示/非表示のタイミングでviewの背景を変える
 override func viewWillLayoutSubviews() {
        let isNavigationBarHidden = navigationController?.isNavigationBarHidden ?? false
        view.backgroundColor = isNavigationBarHidden ? .black : .white
    }





インクリメントサーチ（UISearchBarデリゲート）
   func searchBar(_ searchBar: UISearchBar, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        DispatchQueue.global().asyncAfter(deadline: .now() + 0.1) {
            // 文字入力許可後0.1秒後に検索を開始する
            DispatchQueue.main.async {
                self.presenter.search(word: self.navigationItem.searchController?.searchBar.text)
            }
        }
        return true
    }

@testable import Data

Coredata
Predicateの複数指定
// 検索条件指定
            let searchTitlePredicate = NSPredicate(format: "title CONTAINS[c] %@", searchWord)
            let searchNamePredicate = NSPredicate(format: "speakerName CONTAINS[c] %@", searchWord)
            let searchDescriptionPredicate = NSPredicate(format: "descriptionText CONTAINS[c] %@", searchWord)
            
                        fetchRequest.predicate = NSCompoundPredicate(orPredicateWithSubpredicates: [searchTitlePredicate,
                                                                                                    searchNamePredicate,
                                                                                                    searchDescriptionPredicate])
            l
エンティティの全削除
/// 全件削除
    private func allDelete(entityName: String) {
        let context = CoreDataManager.shered.mainThreadContext()
        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: entityName)
        let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)
        try! context.execute(deleteRequest)
    }


Swiftにおけるclassとstructの使い分け
・カプセル化してプロパティを持ちたいとき・・・struct
・プロパティを持つ必要がない時やカプセル化として使用する必要がない時・・・class
https://cockscomb.hatenablog.com/entry/choosing-between-classes-and-structures


テーブルビューのスクロールビュー一番上まで
tableView.scrollToRow(at: IndexPath(row: 0, section: 0), at: .top, animated: false)


protcolをオプショナル（実装必須ではない）にする

以下の書き方を参考にする

public protocol UIApplicationDelegate : NSObjectProtocol(どのobjectを対象にするかなので、classでも良い) {
optional public func applicationDidFinishLaunching(_ application: UIApplication)
}

// 各画面が必要に応じてデリゲートを受けられるようにオプショナル型で宣言
@objc public protocol CoreDataManagerDelegate: class {
    /// 全ての記事情報を取得
    @objc optional func fetchedAllArticleItems(_ items: [ArticleItem])
    /// カテゴリー指定で記事情報を取得
    @objc optional func fetchedArticleItemsByCategory(_ items: [ArticleItem])
    /// 記事情報の取得に失敗
    func failedFetch(error: Error)
    // TODO: - 各種処理のエラーハンドリングが必要
}


スクロールを検知する方法（上に、下に）
1. Viewでスクロールの開始位置と開始タイミングをデリゲートでキャッチ
func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
        // スクロールごとに開始ポイントをプロパティに保持する(    var beginScrollPoint = CGPoint(x: 0, y: 0)
)
        presenter.beginScrollPoint = scrollView.contentOffset
    }
    
func scrollViewDidScroll(_ scrollView: UIScrollView) {
        presenter.didScroll(contentOffsetY: scrollView.contentOffset.y)
    }


2. Presenterで上にスクロールor下スクロールを判定（上で取った開始位置を渡してあげる）
 /// スクロールを監視
    ///
    /// - Parameter contentOffsetY: Y軸のスクロール値
    func didScroll(contentOffsetY: CGFloat) {
// プロトコルを着火してView側で何かする（Bool値を渡している）
        interface?.searchBarIsHidden(beginScrollPoint.y < contentOffsetY)
    }
例：
presenter側
  /// サーチバーの表示非表示を切り替える
    func searchBarIsHidden(_ isHidden: Bool)
view側
    func searchBarIsHidden(_ isHidden: Bool) {
//        navigationItem.hidesSearchBarWhenScrolling = isHidden
    }


文字を入れた場合のサイズをとる
 let categrySize = presenter.categoryList[indexPath.row].title.size(withAttributes: [NSAttributedString.Key.font: UIFont.systemFont(ofSize: 15.0)])


サーチバーをナビばーに入れる
 let searchController = UISearchController(searchResultsController: nil)
        navigationItem.searchController = searchController
        searchController.searchResultsUpdater = self
        // 検索バーの下の空間を検索結果か検索候補どちらにするかを決める（true: 検索候補、false: 検索結果）
        searchController.obscuresBackgroundDuringPresentation = false
        // UISearchControllerをUINavigationItemのsearchControllerプロパティにセットする。
        // trueだとスクロールした時にSearchBarを隠す（デフォルトはtrue）
        // falseだとスクロール位置に関係なく常にSearchBarが表示される
        navigationItem.hidesSearchBarWhenScrolling = true


largetitleの色変更
UINavigationBar.appearance（）。largeTitleTextAttributes = 
    [NSAttributedStringKey.foregroundColor：UIColor.green]


  /// PullToRefresh時のアクション
    @objc func pullToRefresh(sender: UIRefreshControl) {
        interface?.startIndicator()
        datasource.callApi(type: .droidAPI(parameters: [:]))
    }

PullToRefresh プル
let refreshControl = UIRefreshControl()
            refreshControl.tintColor = .white
            refreshControl.addTarget(presenter,
                                     action: #selector(presenter.pullToRefresh(sender:)),
                                     for: .valueChanged)
            tableView.refreshControl = refreshControl

タップしたテーブルビューの大きさを取得
let cellFrame = tableView.convert(tableView.rectForRow(at: indexPath),
                                          to: tableView.superview)

サブクラスのVCのステータスバーの色をセットする
class ThemeViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        setNeedsStatusBarAppearanceUpdate()
    }
    
    override var preferredStatusBarStyle: UIStatusBarStyle {
        return .lightContent
    }
    
}

ナビゲーションコントロラーの子の時はナビVCクラスを作って以下をoverrideする必要あり
override var childForStatusBarStyle: UIViewController? {
        return self.visibleViewController
    }
    
    override var childForStatusBarHidden: UIViewController? {
        return self.visibleViewController
    }


self のアンラップ
guard let `self` = self else { return }
マルチスレッドで CoreDataのオブジェクトを扱えるようにするにはスレッドごとに NSManageObjectContextを用意する必要があります。

throws ・・・do catch以外の要素を使うときはメソッド自体をthrowsにする（ifで対応できる）

delegateをweakで持てないのはprotocolがclass対象になっていないから

@IBOutlet weak var restrantListTableView: UITableView! {
        didSet {
            // テーブルビューの各種設定
        // デリゲート
            restrantListTableView.delegate = self
        // データソース
            restrantListTableView.dataSource = self
        // カスタムセルの登録
            restrantListTableView.register(UINib(nibName: RestrantInfoCell.identifier, bundle: nil),
                                           forCellReuseIdentifier: RestrantInfoCell.identifier)
        // カスタムフッター用セルの登録
            restrantListTableView.register(UINib(nibName: ReloadView.identifier, bundle: nil),
                                           forCellReuseIdentifier: ReloadView.identifier)
        // カスタムフッターの登録（上記で用意したセルを当てる）
            if let reloadView = restrantListTableView.dequeueReusableCell(withIdentifier: ReloadView.identifier) as? ReloadView {
                reloadView.indicator.isHidden = true
                restrantListTableView.tableFooterView = reloadView
// 一旦高さ0で隠しておく
                restrantListTableView.tableFooterView?.frame.size.height = 0
            }
        }
    }
    

カスタムフッターの使い方
上記で登録してある前提で

let reloadView = self.restrantListTableView.tableFooterView as! ReloadView
reloadView.indicator.isHidden = isHidden
// 高さを戻して見えるようにする
reloadView.frame.size.height = isHidden ? 0 : 50


// それぞれの準拠元で柔軟的に型を決定できる値（protcol版ジェネリクス）
    associatedtype ViewObject
    // Presenterクラス側でViewクラスを保持する用propatie
    // デフォルト実装で、自動的に渡されたViewクラスをPresenterクラスのinterface変数(protcol)にセットする
    var interface: ViewObject? { get set }

 /// lacalのjsonファイルのpathを取得
    ///
    /// - Parameter fileName: ファイル名
    /// - Returns: jsonファイルのpath(失敗の場合はnil)
    func getLocalJsonFilePath(fileName: String) -> String? {
        return Bundle.main.path(forResource: fileName, ofType: "json")
    }



/// TestProjectに置いてあるlacalのjsonファイルのpathを取得（json自体のmembershipで本環境の方を許可する）
    ///
    /// - Parameter fileName: ファイル名
    /// - Returns: jsonファイルのpath(失敗の場合はnil)
    func getLocalJsonFilePathFromTestPJ(fileName: String) -> String? {
        return Bundle(for: type(of: self)).path(forResource: fileName, ofType: "json")
    }

@testable 
テスト用、アクセスレベルinternalまでのデータにアクセスできるようになる

MVPとMVVMの違い
MVP・・・ViewとPresenterが参照しあう（お互いに保持する、Presenter側はプロトコル準拠したViewを保持）
MVVM・・・ViewとPresenterがお互いを知らない（保持しない）
→ View側でPresenter側のプロパティを監視する（プロパティ名だけで繋がるため、お互いに保持しない、疎結合になるためテストしやすい）


Emmbedframeworkの導入
/// 外部からinitできるようアクセスレベルを変更（必須）
    public init() {}


cocoaPodsKeyをいれた後の呼び出し方
private let apiAccessKey = MVPAPISampleXcodeprojKeys().gurunaviApiKey

DI・・・初期値を持たせて初期化する（期待の結果を持たせてインスタンスを作ること）

presenterはweakでもつ・・・VCから参照する、presenterからVCを参照する相互参照から

associatedtype 変数名・・・プロトコル内で使えるジェネリクス（presentterのinitをジェネリクス化　base interfice）


NVActivityIndicatorViewの使い方
デフォルトのインジケーターで良い場合（シングルトンであらかじめ定義されているデフォルトをそのまま使う、文字のセットはできる）
インポート
スタート
NVActivityIndicatorPresenter.sharedInstance.startAnimating(ActivityData(message: "データ取得中"))
ストップ
NVActivityIndicatorPresenter.sharedInstance.stopAnimating()

全部いじれるのはNVActivityIndicatorViewをインスタンス化してプロパティでもつ方法

使いやすい方法
protcol（NVActivityIndicatorViewable）を準拠するとstart,stopが使える、タイプも変えれる

codableも持ちプロパティに初期値を与えれば空で定義できる
protcolのデフォルト実装を型指定で行う
extension protcolName where Self: UITableViewCell(指定する型) {
// 何か
}


ナビバーのタイトルの更新
self.navigationItem.title = title

ナビバーの戻るボタンのデフォルトタイトルを消す
storyboradのnavigationItemsのbackbuttonに空白入れる

Dispatch queue
また、DispathcQueue自体に、Serial、Concurrent、mainの３種類が存在します。
それぞれ以下のように分類されています（公式ドキュメントも参照）。

Serial：登録したタスクを、同時並行ではなく、登録した順に実行
作り方：自身でラベル生成
Concurrent：登録したタスクを、同時並行で実行
デフォルトで用意されてqueue使う（global等）

main：メインのUIスレッドでの実行。主にタスク内でUI操作を行う時などで使用


CoreDataのロールバック（保存結果戻し）
managedContext.rollback()

URL UIImage 変換
static func getImage(urlString: String) -> UIImage? {
        do {
            guard let url = URL(string: urlString) else { return nil }
            let imageData = try Data(contentsOf: url, options: .mappedIfSafe)
            return UIImage(data: imageData) ?? nil
        } catch {
            return nil
        }
    }

 static func getImage(urlString: String) -> UIImage {
        do {
            guard let url = URL(string: urlString) else { return UIImage(named: "defaultImage")! }
            let imageData = try Data(contentsOf: url, options: .mappedIfSafe)
            return UIImage(data: imageData) ?? UIImage(named: "defaultImage")!
        } catch {
            return UIImage(named: "defaultImage")!
        }
    }



キーボード設定
enablesReturnKeyAutomatically：trueなら未入力のときリターンきーを無効にする、デフォルトfalse
ローカルファイルのpath取得
 guard let filePath = Bundle.main.path(forResource: "UserData-Sample", ofType: "json") else {
            fatalError("json is not found in main Bundle.")
        }

配列　指定した方以外の値を削除する　取り除く
flatMap(返り値使用しない)compactMap(返り値使用する)
nil、optional削除
["1", "2", "3"].map { Int($0) } // → [Optiona(1), Optiona(2), Optiona(3)]
["1", "2", "3"].flatMap { Int($0) } // → [1, 2, 3]
形違い削除
["1", "2", "string", "3"].map { Int($0) } // → [Optiona(1), Optiona(2), nil, Optiona(3)]
["1", "2", "string", "3"].flatMap { Int($0) } // → [1, 2, 3]


lazy var プロパティ名 = 変数またはメソッド
レイジープロパティとは
レイジープロパティ（lazy stored property）とは、参照されるときに初めて初期値が設定されるプロパティのことである。
レイジープロパティは以下のように定義する。インスタンス生成後に値を変更するプロパティなので定数（let）で宣言することはできない。

セルのレイアウト
複数の制約のONOFFを使い分ける場合は遠い方から設定
どっちを優先するかを決めるのは、Content Hugging Priority
中からの力が弱く潰れるときは　Content Compression Resistance Priority を強くする
２つのラベルは伸ばしたい方から制約をきめるその後、Content Hugging Priorityをいじる

値を代入する	set…
値を取得する	get…
計算する	calculate…
変換する	convert…to…
真偽値を返す	is…

let ddd: (型A && 型B) で２種のクラスを持った変数を宣言できる（プロトコルをつけたクラスなど）

今後学習
rakeコマンドの設定をする

enmuにプロパティを持たせるには、enumu内で定義して varで作って　リターンする
enum・・・固定の値
struct・・・使い回す値
defer{}
処理の中が全部終わった後に実行される

initの時点でのdidset,willsetは呼ばれない

cocoapods-key(.envファイルに書き出す) 開発者個人の情報はそこに書く


メモリーリークが出た場合
xcode > open tool > instruments > link


簡単な確認法
ブレイクで止めて左下の!ボタンでメモリーリークしている箇所だけ出せる


テーブルビューのデリゲートクラスで、スクロールで画面外のセルに対して、アクションを提示できる
セルの作成はしないため、はめるようのパーツの用意などをしておける（画像など）
ただ、セルクラスで初めてダウンロードする場合は、意味ない、このデリゲートであらかじめ、ダウンロードした画像を配列として用意しておくか、ローカルのDBに入れるなどして持っておくと
ダウンロードの手間と時間を省ける
prefetchDataSource


デリゲートはプロトコルをつないでいくデザインパターン（引数、戻り値が固定のため、ロジックに左右されない）
protcolは準拠していれば、絶対にprotcolメソッドを書かないといけないが、
extentionでデフォルトメソッド内容を書いておけば書かなくてもよくなる（optional的なやつ）
デフォルト実装書いてあれば、準拠先からselfのメソッドとしてデフォルトも呼べるし、準拠先に同名のメソッドを定義すれば、そっちが呼ばれる（デフォルトに勝てる）

control+command+R でビルドせずにアプリを再起動できる

プロトコルに準拠したコントローラーの書き方（どっちのメソッドも使える）
vc: AreaListInterface & UIViewController

add subview ・・・配列の一番後ろに入れる
insert subview・・・指定したところに入れる（対象は順番でも指定のviewの後ろとかでもいける）

通知説明
http://xyk.hatenablog.com/entry/2016/11/02/180204
Xcode で Today Extension のデバッグ時にブレークポイントを有効にする方法
http://www.minimalab.com/blog/2014/09/27/today-extension-degug/

プッシュ通知のデバイストークンの取得方
extension String {
    public init(deviceToken: Data) {
        self = deviceToken.map { String(format: "%.2hhx", $0) }.joined()
    }
}

/// 通知受け取り時にextensionでtoken生成
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data!) {
    let token = String(deviceToken: deviceToken)
}

一定時間後に処理を実行する方法
DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
    // 0.5秒後に実行したい処理
}

値渡し、戻る
// 遷移元のVCを取得して値渡し
        guard
            let navigationController = self.navigationController,
            let memoListController = navigationController.viewControllers[navigationController.viewControllers.count - 2] as? MemoListController else {
            // 何もせずに戻る
            self.navigationController?.popViewController(animated: true)
            return
        }
        // 結果をリスト画面に渡して戻る
        memoListController.databaseActionType = type
        memoListController.databaseError = error
        
        self.navigationController?.popViewController(animated: true)



応用で指定の文字列を削除した上で文字列を返すことができるよ！！
/// 文字列が「空文字orスペースのみ」でないかを判定
    ///
    /// - Parameter title: チェックする文字列
    /// - Returns: true: 空文字orスペースのみ、false: スペースではないテキストが1文字以上入っている
    private func hasText(title: String) -> Bool {
        var checkTitle = title
        while true {
            guard let range = checkTitle.range(of: " ") else {
                break
            }
            checkTitle.removeSubrange(range)
        }
        return checkTitle.isEmpty
    }

public extension String {
    /// 文字列を”１行目”と”２行目以降”に分ける
    ///
    /// - 2行以上の文章　= [１行目, それ以降の文章]
    /// - 1行の文章　= [１行目]
    /// - nil(ありえない)　= []
    func divideFirstLines() -> [String] {
        var lines: [String] = self.components(separatedBy: .newlines)
        guard lines.count >= 1 else { return [] }
        let firstLine = lines[0]
        lines.remove(at: 0)
        guard lines.count >= 1 else { return [firstLine] }
        let otherLine = lines.joined(separator: "\n")
        return [firstLine, otherLine]
    }
}



値渡しでもどる
 // 遷移元のVCを取得して値渡し
        guard
            let navigationController = self.navigationController,
            let memoListController = navigationController.viewControllers[navigationController.viewControllers.count - 2] as? MemoListController else {
            // 普通に戻る
            self.navigationController?.popViewController(animated: true)
            return
        }
        // 結果をリスト画面に渡して戻る
        memoListController.databaseActionType = type
        memoListController.databaseError = error
        
        self.navigationController?.popViewController(animated: true)


排列内のインデックスを順に取得
for (index, value) in memoListCopy.enumerated() {}



ハンドラーhandler
static func update(model: Memo, completion: ((ActionType, Error?) -> Void)) {}

// stringでメソッド名を指定して呼び出す（呼び出しは@objcをつける）
self.perform(Selector("メソッド名"))
// 呼び出しメソッド
@objc private func transitTeamAViewController() {
        //TODO  : チームA
    }

ハンドラー
プロトコルprotcolにデフォルト引数を持たせるときはextension（引数を省略できる、渡しても渡さなくても良い）
extension ProtocolName {
    func errorAlert(message: String, completionHandler: ((Any) -> ())? = nil) {
        let alert = UIAlertController(title: "エラー", message: message, preferredStyle: .alert)
        let alertAction = UIAlertAction(title: "OK", style: .default, handler: completionHandler)
        alert.addAction(alertAction)
        AlertManager.present(alert: alert)
//        self.present(alert, animated: true) // UIViewController自体を持っていない
    }
}

アクセス修飾子

getterもsetterも公開するプロパティ
public var option: Option

getterのみ公開するプロパティ（取得はできるが、変更はできない）
public private(set) var view: CustomView


// ループ処理を抜けるためのラベルをforEachの場合も使えるようにする
extension Array {
    func forEachWithBreak(operation: (Element, () -> ()) -> ()){
        var loop = true
        func fail(){
            loop = false
        }
        label: for item in self {
            operation(item, fail)
            if loop == false {
                break label
            }
        }
    }
}


Codableの使い方

ローカルjsonの取得
if let path = Bundle.main.path(forResource: "test", ofType: "json") {
    do {
          let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .mappedIfSafe)
          let jsonResult = try JSONSerialization.jsonObject(with: data, options: .mutableLeaves)
          if let jsonResult = jsonResult as? Dictionary<String, AnyObject>, let person = jsonResult["person"] as? [Any] {
                    // do stuff
          }
      } catch {
           // handle error
      }
}


// 単一
 do {
      let decoder = JSONDecoder()
      let response = try decoder.decode(codableモデルクラス.self, from: jsonData)
    } catch let error {
      print("error: \(error.localizedDescription)")
    }

// 配列
do {
     let decoder = JSONDecoder()
     let tweetData = try decoder.decode([codableモデルクラス配列用].self, from: jsonData)
    } catch let error {
      print("error: \(error.localizedDescription)")
    }


修飾子に関して

メソッドにも変数にも、アクセス制限はつけれる

fileprivate
同一ファイル内であればアクセスできる

private
メソッドならでないとアクセスできない（一番硬い）

extension（クラス拡張のこと、デリゲートでよく使う）



メソッドは


structはプロパティを持ったプロパティ
Constrains.ToolBar. addFolderButton みたいに使える
struct Constrains {

    /// ツーバーに表示する文字列
    struct ToolBar {
        static let addFolderButton = "addFolderButton".localized()
        static let addTaskButton = "addTaskButton".localized()
        static let deleteAllButton = "deleteAllButton".localized()
    }

テーブルビュー
スワイプ での変更モードの取得　感知（tableviewdelegate）
 func tableView(_ tableView: UITableView, willBeginEditingRowAt indexPath: IndexPath) {
        "変更開始"
    }
    
    func tableView(_ tableView: UITableView, didEndEditingRowAt indexPath: IndexPath?) {
        "変更完了"
    }
    

テーブルビュー　セルがない部分のセパレート線を消す（空行）余分、余白
self.tableView.tableFooterView = UIView()

テーブルビュー　削除　アニメーション付き
 // アニメーション付きで削除
// データソース側の要素を削除後（DBの方も）
self.dataSource.memoList.remove(at: 0)
// 以下のコマンドで削除結果をアニメーション付きで反映
self.memoList.deleteRows(at: [IndexPath(row: 形したrow, section: 消したrowのセクション)], with: .fade)

// 全削除をアニメーションでやる場合
 // アニメーション付きで削除
            for _ in self.dataSource.memoList {
                self.dataSource.memoList.remove(at: 0)
                self.memoList.deleteRows(at: [IndexPath(row: 0, section: 0)], with: .fade)
            }
            self.memoList.reloadData() // 編集で単数削除選択時に全削除すると固まる問題への対応





テーブルビューの編集ボタンアクション
作成
navigationItem.rightBarButtonItem = editButtonItem
モード切り替え
override func setEditing(_ editing: Bool, animated: Bool) {
        super.setEditing(editing, animated: animated)
        memoList.isEditing = editing
    }

オリジナルのタイトルつけるとき
private func setupToolBar(isEditing: Bool) {
        editButton.title = isEditing ?
            Constrains.ToolBar.deleteAllButton : Constrains.ToolBar.addFolderButton
    }

テーブルビュー削除アクション(tableviewDataSource)
 func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
        if editingStyle == .delete {
            self.delegate?.delete(index: indexPath.row)
        }
    }


テーブルビューの選択状態を戻す
override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        if let indexPathForSelectedRow = tableView.indexPathForSelectedRow {
            tableView.deselectRow(at: indexPathForSelectedRow, animated: true)
        }
    }

 // スクロールを上まで戻す
        self.jobOfferListTableView.scrollToRow(at: IndexPath(row: 0, section: 0), at: .top, animated: false)

その値があるのかどうかを確認する方法
guard let ~~~ {
YESの場合の処理
}

pubic
importなどで繋がっていれば参照できるアクセス権限

プロトコル
デリゲートの定義（先頭は大文字で）
protocol Hogedele: class {
    func failedThen()
}

デリゲートプロパティの用意
weak var loadable: hogedele?

デリゲートメソッドの呼び出し
loadable?.failedThen()


コメント
// MARK: - LifeCycle Methods

// MARK: - SetUp Methods

// MARK: - Private Methods

初期化　？
？　＝　alloc initをしていること
初期値があるときは、何かを定義する

! ＝ ?(alloc init)状態から、初めて値が入った時につける
初期値が入っている場合はつけない


アクセス修飾子
制限緩い
open：モジュール外からもアクセスできる。 一番ゆるいアクセスコントロール。 新規追加✨
public：モジュール外からもアクセスできる。 サブクラス化されない。 overrideできない。
internal：モジュール内ならアクセスできる。 何も書かないとコレになる。（デフォルト）
fileprivate：文字通りファイル内ならアクセスできる。 新規追加✨
private：クラスなど宣言内でしかアクセスできない。
制限厳しい


letもvarも先頭小文字

enum内の要素も小文字



urlとdateの命名（URL型かString型かを命名ではっきりさせる）
var thumbnailURL: URL
var imageURLString: String
var lastUpdateDate: Date
var birthdayString: String


if文の書き方　（）がいらない
if names.isEmpty {
    ...
}

コールバックやinitの時だけselfをつける（wselfなどは必要ない）


モダンな書き方
Array・dictionary
var names = [String]()
var jsonDic = [String: AnyObject]()

早期リターンチェック
guard hogehoge else {
    return
}



アラートの表示（ヘルパー利用）
func showAlert(message: String, handler: ((UIAlertAction) -> Void)? = nil) {
        let alert = AlertHelper.alert(message: message, rightButtonAction: handler)
        self.present(alert, animated: true, completion: nil)
    }


戻る処理
self.dismiss(animated: true, completion: nil)

self.navigationController?.popViewController(animated: true)

初回画面まで戻る
self.navigationController?.popToRootViewController(animated: true)


プリント
print
print("中身は\(url)")
:-1: Build input file cannot be found: '/Users/kawaharadai/Library/Developer/Xcode/DerivedData/Stationery-Project-bncjtwhcbynhjwebrmshnajrlmnh/Build/Products/Debug-iphonesimulator/Stationery-Project.app/PlugIns/Stationery-ProjectTests.xctest/Stationery-ProjectTests'

他のバージョンで使う場合のメモ
 // TODO: デザイン確定後修正する

あとで対応予定で残す場合
// FIXME: testJSが不要になったら削除する

シュミレーターのデータ保存先確認・保存場所
 let documentDirPath = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.documentDirectory, FileManager.SearchPathDomainMask.userDomainMask, true)
        print(documentDirPath)

cache.dbを消す時
URLCache.shared.removeAllCachedResponses()

webviewで表示したもののアプリケーションキャッシュ・ブラウザキャッシュを消す
WKWebsiteDataStore.default().removeData(ofTypes: WKWebsiteDataStore.allWebsiteDataTypes(),
                                                modifiedSince: Date(timeIntervalSince1970: 0)) {
                                                    print("remove all cache.")
        }


base64 エンコード、デコード
https://qiita.com/tenten0213/items/6ac8682e3a7e3b378167


NetWorkcacheのみ消せた
WKWebsiteDataTypeDiskCache

/Library/Cookiesを消せた
WKWebsiteDataTypeCookies

どこが消えたかわからない
WKWebsiteDataTypeSessionStorage

以下のアプリケーションキャッシュを消せた
/Library/Caches/com.stv.iQUICK/WebKit/OfflineWebApplicationCache
WKWebsiteDataTypeOfflineWebApplicationCache

NetWorkcacheとWKWebsiteDataTypeOfflineWebApplicationCacheの両方を消せるが、
Web SQL.dbも消えてしまう
 WKWebsiteDataStore.default().removeData(ofTypes: WKWebsiteDataStore.allWebsiteDataTypes(),
                                                modifiedSince: Date(timeIntervalSince1970: 0)) {
        }


リテラルコーディング（＋奥寺さん資料）
 #if FOR_ADMIN
            let text = "admin"
        #elseif FOR_USER
            let text = "user"
        #else
            let text = "dev"
        #endif
        print(text)


アプリの設定ページを編集する
https://qiita.com/akatsuki174/items/392cb3be619fabfa4608
https://github.com/stv-ekushida/ios-licence-auto-make-demo
https://qiita.com/mono0926/items/973752b69c881e00c507#_reference-cad5bf9a515fddc13848


nilでないチェック
openRequestURL != ""
ではなく
!openRequestURL.isEmpty

Bool値の宣言
Bool()ではなく初めからfalseを宣言（初期値がfalseのため）
var notExistURL = false


アプリを強制的に落とす
fatalError("スキームが存在しない")


swiftでFMDB
https://qiita.com/s_emoto/items/5488667478c0339b4e83

podでライブラリのエラーを無視する
pod〜〜の上に
inhibit_all_warnings!
/Users/kawaharadai/xcode sorcefile/sample/DrawerMenu-Sample/DrawerMenu-Sample/Other/Bridging-Header.h

staticをつければ、どこからでも呼べる（クラスメソッド的なやつ）
finalは呼ばなければ絶対にアクセスできないクラス

// 配列の中の要素全体に対して、一つ一つをFolderモデル型に変換している（{}の中であれば$0を一つの要素として見れる）
// 戻り値が必要ないときはmapではなく、forEachを使う
objects.map { Folder(value: $0) }

取り出したものを入れる変数は、Arrayかdic
詳しい使い方は
https://qiita.com/motokiee/items/cf83b22cb34921580a52

for文
(0..<10).map {//処理}

for i in 0..<10 {
    //処理
}

for文内での条件ずけ
条件が複数の時は、fileterで絞ってしまう
for validSite in validSiteList where validSite.path.isEmpty {}


配列　Array
中身の文字列を結合
testArray.joined()


// ピンチアクションの登録
let pinchGesture = UIPinchGestureRecognizer(target: self, action: nil)
self.view.addGestureRecognizer(pinchGesture)

// wkwebviewへのピンチアクションの登録（デフォルトではNO）
http://ioscake.com/wkwebview-equivalent-for-uiwebviews-scalespagetofit.html


ピンチが可能なWKWebView作成
 let jsString = "var meta = document.createElement('meta');" +
            "meta.setAttribute('name', 'viewport');" +
            "meta.setAttribute('content', 'width=device-width'); " +
        "document.getElementsByTagName('head')[0].appendChild(meta);"
        
        let userScript = WKUserScript(source: jsString, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
        
        let wkUController = WKUserContentController()
        wkUController.addUserScript(userScript)
        
        let wkWebConfig = WKWebViewConfiguration()
        wkWebConfig.userContentController = wkUController
        
// ピンチがいらないときは上記は消す
//        let webConfiguration = WKWebViewConfiguration()
        webView = WKWebView(frame: .zero, configuration: wkWebConfig)
        webView?.uiDelegate = self
        webView?.navigationDelegate = self
        webView?.allowsBackForwardNavigationGestures = true
        
        useragent(webview: webView)
        
        view = webView



ユーザーデフォ
userdefault

保存
UserDefaults.standard.set(jsonDataEncrypted, forKey: "settingFile")

取得
let jsonDataEncrypted = UserDefaults.standard.data(forKey: "settingFile"),


string、url変換
String(contentsOf: URL)
URL(string: String)

テーブルビューメソッド
// MARK: - UITableViewDataSource Methods
extension ModeListProvider: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return modeListData.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: MenuViewCell.identifier, for: indexPath) as? MenuViewCell else {
            fatalError("cell is nil")
        }
        return cell
    }}

テーブル　必須
import UIKit

protocol FolderListDataSourceDelegate {
    func delete(index: Int)
}

class FolderListDataSource: NSObject {
    var folderList: [Folder] = []
    var delegate: FolderListDataSourceDelegate?
}

extension FolderListDataSource: UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return self.folderList.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: FolderListCell.identifier, for: indexPath) as? FolderListCell else {
            fatalError("cell is nil")
        }
        return cell
    }
    
    /// 削除のみ
    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
        if editingStyle == .delete {
            self.delegate?.delete(index: indexPath.row)
        }
    }
}


テーブルセル nibの登録(setup時) セル登録
self.folderList.register(UINib(nibName: FolderListCell.identifier, bundle: nil),
                                 forCellReuseIdentifier: FolderListCell.identifier)

セルクラスメソッド(cell)

xibファイルのインスタンスを取得する（テーブルビューなど以外で再利用メソッドがない場合）
class func instance() -> TableViewHeader {
        guard let view = TableViewHeader.nib().instantiate(withOwner: self, options: nil).first as? TableViewHeader else {
            fatalError("failuer get xib")
        }
        return view
    }

自身のidentifierを返す
static var identifier: String {
        return String(describing: self)
    }


自信のnibを返す（xibの登録時に呼ぶ、上と一緒に使う）
static func nib() -> UINib {
        return UINib(nibName: identifier, bundle: nil)
    }
    


/// NSDataのフォーマットを変更
    private func dateFormat(date: NSDate) -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy/MM/dd HH:mm"
        return dateFormatter.string(from: date as Date)
    }
    

// ローカルのJSONをストリングで出力
※ pathの作成でnilになる場合は、「let testBundle = Bundle(for: type(of: self))」を試す
 guard let path = Bundle.main.path(forResource: "btnu_custom_sample2", ofType: "json") else {
                    fatalError("json is not found in main Bundle.")
                }
                
                do {
                     let jsonData = try Data(contentsOf: URL(fileURLWithPath: path))
                    guard let jsonDataString = String(data: jsonData, encoding: .utf8) else {
                        print("変換失敗")
                        return
                    }


エラーして中断
fatalError("TaskListViewController is nil.")


オートレイアウト（コードで）
    private func setConstraint(view: UIView) {
        
//        let statusBarHeight = UIApplication.shared.statusBarFrame.height
        
        view.translatesAutoresizingMaskIntoConstraints = true
        
        let width = NSLayoutConstraint(item: view,
                                       attribute: .width,
                                       relatedBy: .equal,
                                       toItem: self.view,
                                       attribute: .width,
                                       multiplier: 1.0,
                                       constant: 0)
        
        let height = NSLayoutConstraint(item: view,
                                        attribute: .height,
                                        relatedBy: .equal,
                                        toItem: self.view,
                                        attribute: .height,
                                        multiplier: 1.0,
                                        constant: 0)
        
        let xPosition = NSLayoutConstraint(item: view,
                                           attribute: .centerX,
                                           relatedBy: .equal,
                                           toItem: self.view,
                                           attribute: .centerX,
                                           multiplier: 1.0,
                                           constant: 0)
        
        let yPosition = NSLayoutConstraint(item: view,
                                           attribute: .centerY,
                                           relatedBy: .equal,
                                           toItem: self.view,
                                           attribute: .centerY,
                                           multiplier: 1.0,
                                           constant: 30)
        
        let constraints = [width, height, xPosition, yPosition]
        
        view.addConstraints(constraints)
    }


データ型　→ string
guard let jsonString = String(data: jsonData, encoding: .utf8) else {
                    return
                }
                


オブジェクトマッパー
objectmapper

guard let jsonString = String(data: jsonData, encoding: .utf8) else {
            jsonDataError(useCache: jsonClient.useCache)
            return
        }
        
let mapJsonString = Mapper<SettingFileResponse>().map(JSONString: jsonString)



画面遷移
1
guard let webViewController = UIStoryboard(name: "WebView", bundle: nil)
            .instantiateInitialViewController() as? WebViewController else {
                return
        }
        
        webViewController.selectConfigURL = requestConfigURL
        
        present(webViewController, animated: true, completion: nil)



2
 let infoVC = InfomationPageViewController.make(accessURL: AccessInfomation.teamOfService.rawValue)
        self.navigationController?.pushViewController(infoVC, animated: true)


// 遷移先に用意するもの
 class func make(followerId: String?) -> FollowerPageViewController {
        let vcName = FollowerPageViewController.className
        guard let followerVC = UIStoryboard.viewController(
            storyboardName: vcName, identifier: vcName) as? FollowerPageViewController else {
                fatalError("FollowerPageViewController is nil.")
        }
        followerVC.followerId = followerId
        return followerVC
    }




並列処理
非同期処理
// サブスレッドで実行
DispatchQueue.global(qos: .default).async {
  // サブスレッド(バックグラウンド)で実行する方を書く 
    DispatchQueue.main.async {
        // Main Threadで実行する
    }
}


画面外タップでキーボードとじる
@IBAction func tapBackground(_ sender: Any) {
        self.view.endEditing(true)
    }


キーボードの出し入れのタイミングで画面をあげる　隠れないようにする
 /// キーボードの出し入れのタイミングの通知を登録
    private func registKeyboardNotification() {
        let notification = NotificationCenter.default
        notification.addObserver(self, selector: #selector(self.keyboardWillShow(notification:)), name: UIResponder.keyboardWillShowNotification, object: nil)
        notification.addObserver(self, selector: #selector(self.keyboardWillHide(notification:)), name: UIResponder.keyboardWillHideNotification, object: nil)
    }


キーボードをあげる処理
 guard let self = self,
                    let rect = (notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue,
                    let duration = notification.userInfo?[UIResponder.keyboardAnimationDurationUserInfoKey] as? Double else {
                        return
                }

                UIView.animate(withDuration: duration,
                               animations: { () in
                                // 画面をキーボード分あげる
                                let transform = CGAffineTransform(translationX: 0, y: -(rect.size.height))
                                self.view.transform = transform

                })



/// キーボードが表示されたときの処理
    ///
    /// - Parameter notification: 通知情報
    @objc func keyboardWillShow(notification: Notification) {
        let rect = (notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue
        let duration = notification.userInfo?[UIResponder.keyboardAnimationDurationUserInfoKey] as? Double
        UIView.animate(withDuration: duration!,
                       animations: { [weak self] () in
                        let transform = CGAffineTransform(translationX: 0,
                                                          y: -(rect?.size.height)!)
                        self?.view.transform = transform
                        
        })
    }
    
    /// キーボードが非表示されたときの処理
    ///
    /// - Parameter notification: 通知情報
    @objc func keyboardWillHide(notification: Notification) {
        let duration = notification.userInfo?[UIResponder.keyboardAnimationCurveUserInfoKey] as? Double
        UIView.animate(withDuration: duration!,
                       animations: { [weak self] () in
                        self?.view.transform = CGAffineTransform.identity
        })
    }



enterpreice


コードでオートレイアウト
view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "H:|[v0]|",
                                                           options: NSLayoutFormatOptions(),
                                                           metrics: nil,
                                                           views: ["v0": webView ?? WKWebView()]))
        view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "V:|-20-[v0]|",
                                                           options: NSLayoutFormatOptions(),
                                                           metrics: nil,
                                                           views: ["v0": webView ?? WKWebView()]))


テーブルビュー関連
// テーブルビュー：セクションヘッダーの高さ変更
    func tableView(_ tableView: UITableView,
                   heightForHeaderInSection section: Int) -> CGFloat {
        return modeListHeaderSize
    }
    // テーブルビュー：セルの高さ
    func tableView(_ tableView: UITableView,
                   heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 100
    }
    
    // テーブルビュー：ヘッダーアレンジ
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        
        let headerView = UIView(frame: CGRect(x: 0,
                                              y: 0,
                                              width: tableView.frame.width,
                                              height: modeListHeaderSize))
        
        // 背景色
        headerView.backgroundColor = UIColor.black

        let titleLabel = UILabel()
        titleLabel.frame = CGRect(x: 20,
                                  y: 0,
                                  width: headerView.frame.width,
                                  height: headerView.frame.height)
        
        // 文字位置
        titleLabel.textAlignment = .left

        // 文字サイズ
        titleLabel.font = UIFont.boldSystemFont(ofSize: 25)

        // 文字色
        titleLabel.textColor = UIColor.white

        // 表示される文字
        titleLabel.text = "起動するアプリケーションを選択してください。"
        
        headerView.addSubview(titleLabel)
        
        return headerView
}
    
    // テーブルビュー：タップ時の処理
    func tableView(_ tableView: UITableView,
                   didSelectRowAt indexPath: IndexPath) {
        UserDefaults.standard.set(indexPath.row, forKey: "selectConfigURLNamber")
        transionScreen(requestConfigURL: self.provider.modeDataList[indexPath.row])
    }




回してStringからURLにする

guard let url = URL(string: "何かしらのURL") else {
                            self.userProfileImage.image = #imageLiteral(resourceName: "setting_user_icon")
                            return
                        }
                        self.userProfileImage.kf.setImage(with: url)


画面サイズ
let width = UIScreen.main.bounds.size.width
let height = UIScreen.main.bounds.size.height


コードでボタン作る

private func createBackButton() {
        
        let screenWidth: CGFloat = self.view.frame.width
        let screenHeight: CGFloat = self.view.frame.height
        
        let backButton = UIButton()
        
        backButton.frame = CGRect(x: screenWidth * 0.09, y: screenHeight * 0.03,
                                  width: screenWidth * 0.1, height: 60)
        
        backButton.setTitle("back", for: UIControlState.normal)
        
        backButton.titleLabel?.font = UIFont.boldSystemFont(ofSize: 30)
        
        backButton.setTitleColor(UIColor.buttonTitleNomal, for: .normal)
        backButton.setTitleColor(UIColor.buttonTitleHilight, for: .highlighted)
        backButton.backgroundColor = UIColor.buttonBackGround
        backButton.alpha = 0.9
        
        backButton.layer.masksToBounds = true
        backButton.layer.cornerRadius = 10
        backButton.layer.borderColor = UIColor.buttonBorder.cgColor
        backButton.layer.borderWidth = 1.0
        
        backButton.addTarget(self,
                             action: #selector(PDFWebViewController.buttonTapped(sender:)),
                             for: .touchUpInside)
        
        self.pdfWebView?.addSubview(backButton)
    }



    
    @objc func buttonTapped(sender: AnyObject) {
        self.dismiss(animated: true, completion: nil)
    }

        
繰り返し for
for i in 0...14 {
    // 処理
}

ログ、print 
 // 列のセルのdeleteCheckFlgが全てtrueの場合、その列は映さない
            print("--------------------------------------------------")
            print(self.provider.cellItems.count)
            print("--------------------------------------------------")


textViewの文字数制限
func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {

    let currentText = textView.text ?? ""
    guard let stringRange = Range(range, in: currentText) else { return false }
    let changedText = currentText.replacingCharacters(in: stringRange, with: text)
    return changedText.count <= 399 // Pass your character count here 
}



特定の文字列を指定して、そこから分割して配列にする
 guard let separateString = webView.url?.absoluteString.components(separatedBy: "=") else {
                print("Instagramのアクセストークンの取得に失敗")
                return
            }



URLのエラーを拾う（WKWebView）

func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation, withError error: Error) {
        
        handleError(error: error)
    }

func handleError(error: Error) {
        if let failingUrl = error.userInfo["NSErrorFailingURLStringKey"] as? String {
            
            print("-----------------failingUrl-------------------------")
           print(failingUrl)
            print("------------------failingUrl------------------------")

            setUrl(url: "https://qiita.com/peta-m175/items/102d6d723fd87e722f83")
            
            webView?.evaluateJavaScript("location.href=endLoading()", completionHandler: { (html, error) -> Void in
            
                print("実行完了")
            })
        }
    }

UISearchBar
seachBar

seachBar.delegate = self
// テキストフィールド内のクリアボタンを消す
if let textfield = recordSearchBar.value(forKey: "searchField") as? UITextField {
            textfield.clearButtonMode = .whileEditing
        }

// UISearchBarDelegate
// 検索ボタンタップ時
 func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        guard let searchWord = searchBar.text else {
            return
        }
        
        searchBar.setShowsCancelButton(false, animated: true)
        searchBar.resignFirstResponder()
//        recordSearchAPI.requestAPI(seachWord: searchWord)
    }
    
// 入力開始時
    func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
        searchBar.text = ""
        searchBar.setShowsCancelButton(true, animated: true)
    }
    
// キャンセルボタンタップ時
    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
        if searchBar.canResignFirstResponder {
            searchBar.setShowsCancelButton(false, animated: true)
            searchBar.resignFirstResponder()
        }
    }

通知関連（notification）
登録（基本コントローラーで登録して,deinitで削除）


 let notificationCenter = NotificationCenter.default
        notificationCenter.addObserver(self,
                                       selector: #selector(removePartnerIDFromSharedInstance(notification:)),
                                       name: .removePartnerIDFromSharedInstance,
                                       object: nil)

        setupPageViewController()
    }

    deinit {
        NotificationCenter.default.removeObserver(self, name: .removePartnerIDFromSharedInstance, object: nil)
    }


notificationトリガー
let notificationCenter = NotificationCenter.default
        notificationCenter.post(.init(name: Notification.Name("removePartnerIDFromSharedInstance")))
※ もしくわ
    static let removePartnerIDFromSharedInstance = Notification.Name("removePartnerIDFromSharedInstance")をexetensionで定義していれば
以下でいける
.removePartnerIDFromSharedInstance



通知（バックグラウンド処理）
        let center = NotificationCenter.default

//        center.addObserver(self,
//                           selector: #selector(self.didEnterBackground(notification:)),
//                           name: Notification.Name.UIApplicationDidEnterBackground,
//                           object: nil)

アクション	
//    @objc private func didEnterBackground(notification: Notification) {
//        print("didEnterBackground")
//        // バックグラウンドに入った時
//        self.schemeStart = false
//    }

クロージャの書き方（戻り値ない版）
メソッド側（この中の処理が終わったら〜する）
private func getProfileData(uuid: String, completionBlock: (() -> Void)? = nil) {}

呼ぶ側
getProfileData(uuid: uid, completionBlock: {
                    self.selectLibraryView.fadeInAnimation(type: .slow, completed: nil)
                })




web view URL追跡
//        // 表示中のWebページのURLを追跡
    var observeLoading: NSKeyValueObservation?


//                self.observeLoading = self.webView?.observe(\.url, options: [.new]) {_, change in
//                    guard let changeResult = change.newValue.unsafelyUnwrapped else {
//                        return
//                    }
//                    let urlString = changeResult.absoluteString
//
//                    // オンライン時
//                    UserDefaults.standard.set(urlString, forKey: "currentOpenURL")
//                }



URLからパラメータを取り出す属性を追加（URL["keyで取り出す"]）


定義と同時に値をセット
@IBOutlet private weak var addUserButton: UIButton! {
        didSet {
            addLayer(view: addUserButton,
                     corner: addUserButton.frame.width / 4.3,
                     borderColor: .black,
                     borderWidth: 0)
        }
    }


ランダムの文字列を作成
import UIKit
 
extension String {
    static func getRandomStringWithLength(length: Int) -> String {
        
        let alphabet = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        let upperBound = UInt32(alphabet.characters.count)
        
        return String((0..<length).map { _ -> Character in
//            return alphabet[alphabet.startIndex.advancedBy(Int(arc4random_uniform(upperBound)))]
            return alphabet[alphabet.index(alphabet.startIndex, offsetBy: Int(arc4random_uniform(upperBound)))]
        })
    }
}



navigationController 遷移カスタマイズ
 private func customTranstlation(navigationController: UINavigationController?) {
        let transition = CATransition()
        transition.duration = 1
        transition.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)
        transition.type = kCATransitionFade
        navigationController?.view.layer.add(transition, forKey: nil)
    }


セルクラスでレイアウトを足すタイミング
override func draw(_ rect: CGRect) {
        super.draw(rect)
        setLayer()
    }








if let decodeData = Data(base64Encoded: base64String, options: .ignoreUnknownCharacters) {
        yourWebView.load(decodeData, mimeType: "application/pdf", textEncodingName: "utf-8", baseURL: URL(fileURLWithPath: ""))
} // since you don't have url, only encoded String




dispatch main async
非同期処理の中で、メインスレッドの動作を指定したいときは、この表記の中でやる


didSetは、「そのプロパティに値が入った後に走るメソッド」


collectionView,TableView のスクロールを最後までは、
indexを指定して、そこまで移動にする（indexの数-1でわかる）


時間を指定して止める
DispatchQueue.main.asyncAfter(deadline: .now() + 秒数, execute: hanndolar)



なんかのイベントがあって、（input）
そのイベントでどうなるか？（output）（設計書）

クラス一覧（DB設定もいる）
クラス関連ず（矢印で処理順を書く）




ブレイクポイント

po url〜



URLの拡張子を取得
let path = NSString(string: "http://tecc0.com/index.html")
 
print(path.lastPathComponent) // index.html
print(path.pathExtension) // html


URLの先頭文字列のチェック
let hasHttp = requestURL.absoluteString.hasPrefix("http")


webviewで履歴から指定のページに遷移する
 let backPageCount = 2
        guard let urlHistory = webView?.backForwardList.backList else {
            print("閲覧履歴がありません。")
            self.view.window?.rootViewController?.dismiss(animated: true, completion: nil)
            return
        }
        setUrl(url: urlHistory[urlHistory.count - backPageCount].url.absoluteString)


Userdefoのデータはアプリ内の「Preferences」に入っている
キャッシュと同じ確認法


info.plistはcopybundle resoruseに入れない
合ったら、lintに怒られる

error型の文字列
error.localizedDescription



stringファイル使用

・stringクラスを拡張
extension String {

    func localized() -> String {
        return NSLocalizedString(self, comment: "")
    }
}

・stringファイル
// MARK: - Alert Button
"ALERT_OK" = "OK";

// MARK: - Message
"OFFLINE" = "通信環境の良い場所で再度お試しください。";
"TIMEOUT" = "タイムアウトになりました。";
"SESSION_IS_NIL" = "セッションが切れています。\n再度お試しください。";
"FAILED_TO_GET_TIMELINE" = "タイムラインの取得に失敗しました。";


・stringファイル作成後の呼び出し
"指定したキー".localized()



キーボードの上にボタン追加
 //キーボード上部に「完了」ボタンを追加（キーボード設定によりreturnキーがなくなっているため）
    private func addKey() {
        
        //デフォルトカラーを作成（ボタンの文字色用）
        let default_color1 = #colorLiteral(red: 0.07450980392, green: 0.5647058824, blue: 1, alpha: 1)
        let default_color2 = #colorLiteral(red: 0.07450980392, green: 0.5647058824, blue: 1, alpha: 0.3)
        
        // デバイスごとのスクリーン幅と高さを取得
        let screen_width = UIScreen.main.bounds.width
        let screen_height = UIScreen.main.bounds.height
        // ボタンを追加するためのViewを生成
        let onKeyboard = UIView(frame: CGRect(x: 0,
                                              y: 0,
                                              width: screen_width,
                                              height: screen_height / 14))
        // viewの色を指定
        onKeyboard.backgroundColor = UIColor.white
        
        // 完了ボタンの生成
        let btn = UIButton(frame: CGRect(x: screen_width-screen_width / 4,
                                         y: 0,
                                         width: screen_width / 4,
                                         height: screen_height / 14))
        //ボタンの背景を設定
        btn.backgroundColor = UIColor.white
        //ボタンのtitleを設定
        btn.setTitle("完了", for: .normal)
        //ボタンのフォントを設定
        btn.titleLabel?.font = UIFont.systemFont(ofSize: UIFont.main_text)
        //titleを中央寄せ
        btn.contentHorizontalAlignment = .center
        //押したときの色と押してない時の色を設定
        btn.setTitleColor(default_color1, for: .normal)
        btn.setTitleColor(default_color2, for: .highlighted)
        //ボタンをおした時の実行メソッドを設定
        btn.addTarget(self,
                      action: #selector(MainViewController.close_keyboard),
                      for: .touchUpInside)
        // viewへ完了ボタンを追加
        onKeyboard.addSubview(btn)
        //テキストフィールドにキーボード用のviewを追加
        totalfee_text.inputAccessoryView = onKeyboard
        people_text.inputAccessoryView = onKeyboard
    }


アラート　ヘルパー
import UIKit

final class AlertHelper {

    static func buildAlert(title: String = "",  // 初めから入れておくパターン
                           message: String,
                           rightButtonTitle: String = "ALERT_OK".localized(), // stringファイルから引っ張るパターン
                           leftButtonTitle: String? = nil, // 無いことにするパターン
                           rightButtonAction: ((UIAlertAction) -> Void)?, // アクションをセット
                           leftButtonAction: ((UIAlertAction) -> Void)? = nil) -> UIAlertController {

        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        let positiveAction = UIAlertAction(title: rightButtonTitle, style: .default, handler: rightButtonAction)
        alert.addAction(positiveAction)

        if let leftButtonTitle = leftButtonTitle {
            let negativeAction = UIAlertAction(title: leftButtonTitle, style: .cancel, handler: leftButtonAction)
            alert.addAction(negativeAction)
        }
        return alert
    }
}


info.plistをターゲットからコピーで追加した時は、右メニューの参照先が絶対パスになっているので、相対パスになおす（reratibegroup）



git操作
# GitHubへアップロードしたいプロジェクトディレクトリへ移動
$ cd /path/to/your/project
$ git init

# 必要であれば.gitignoreを作成し、バージョン管理しないファイルやディレクトリを記載（例：*.log）
$ vim .gitignore

# コミット 
$ git add .
$ git commit -m "Initial Commit"

# 先ほど作成したGitHubリポジトリのURLをコピー&ペーストして、リモートブランチとして設定
git remote add origin https://github.com/your-name/project-name.git

# push
git push -u origin master


ブランチの確認
ローカルブランチを確認する
git branch
リモートブランチを確認する
git branch -r
上記２つを一度に行う
git branch -a

差分の確認
git diff

現在のブランチから派生ブランチを作成する
git branch BN

作業ブランチを変更する
git checkout BN

上記２つを一度に行う
git checkout -b BN

Git強制チェックアウト
git checkout --force <ブランチ名>

現在の作業ブランチに指定ブランチをマージする
git merge BN
マージ後でも、元に戻せるようにする
git merge --no-ff BN
ブランチの削除
git branch -d BN
ブランチの削除(強制的)
git branch -D BN
リモート・リポジトリにブランチをプッシュする
git push origin BN
リモートブランチからローカルブランチを作成する
git checkout -b BN origin/BN
リモートリポジトリのブランチを取得して、ローカルブランチとする
git fetch origin RemoteBN:LocalBN
リモートブランチを削除する
git push origin :BN
ブランチの派生元ブランチを変更する
git rebase BN
ブランチを比較する
git diff BN1 BN2


通知（WillEnterForeground）
private func registeNotification() {
        let center = NotificationCenter.default
        center.addObserver(self,
                           selector: #selector(self.willEnterForeground(notification:)),
                           name: Notification.Name.UIApplicationWillEnterForeground,
                           object: nil)
    }
    
    @objc private func willEnterForeground(notification: Notification) {
       // アクション
    }

// 通知削除
    private func removeNotification() {
        let notificationCenter = NotificationCenter.default
        notificationCenter.removeObserver(self)
    }

暗号化データ→データの復号化（base64）
let newData = Data(base64Encoded: 暗号化データ(Data))

// アプリの状態を取得（バックグラウンドなど）
UIApplication.shared.applicationState


コードでWKwebViewのautolayout
 private func constainWebView(webView: WKWebView?) {
        webView?.translatesAutoresizingMaskIntoConstraints = false
        
        view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "H:|[v0]|",
                                                           options: NSLayoutFormatOptions(),
                                                           metrics: nil,
                                                           views: ["v0": webView ?? WKWebView()]))
        view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "V:|-20-[v0]|",
                                                           options: NSLayoutFormatOptions(),
                                                           metrics: nil,
                                                           views: ["v0": webView ?? WKWebView()]))
    }

jSの埋め込み
private func setJSAction() -> WKWebViewConfiguration {
        let jsString = "何かのスクリプト"
        
        let userScript = WKUserScript(source: jsString, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
        
        let wkUController = WKUserContentController()
        wkUController.addUserScript(userScript)
        
        let wkWebConfig = WKWebViewConfiguration()
        wkWebConfig.userContentController = wkUController
        
        return wkWebConfig
    }

呼び出すとステータスバーを作る（クラスごとに呼ぶ）
extension UIViewController {
    func setStatusBarBackgroundColor() {
        let statusBarBackground = UIView(frame: CGRect(x: 0,
                                                       y: 0,
                                                       width: self.view.bounds.width,
                                                       height: UIApplication.shared.statusBarFrame.height))
        statusBarBackground.backgroundColor = UIColor.black
        
        self.view.addSubview(statusBarBackground)
    }
}


パラメータをkeyで取り出せる
static func parameterDic(parameter: String) -> [String: String] {
        
        var parameters = [String: String]()
        let pairs = parameter.components(separatedBy: "&")
        
        for pair in pairs {
            let elements = pair.components(separatedBy: "=")
            let key = elements[0].removingPercentEncoding
            let value = elements[1].removingPercentEncoding
            
            if let key = key, let value = value {
                parameters[key] = value
            }
        }
        return parameters
    }


テストコードの比較式
https://qiita.com/shirochan/items/10271912289dc563cc36


ページ間の値受け渡し
// 受け取る側に以下を設定
// MARK: - Factory
    class func make(url: String) -> DetailViewController {
        let storyboard = UIStoryboard(name: DetailViewController.identifer, bundle: nil)
        guard let detailViewControllerVC = storyboard.instantiateViewController(withIdentifier: DetailViewController.identifer) as? DetailViewController else {
            fatalError("VCのインスタンス化に失敗")
        }
        detailViewControllerVC.accessURL = url
        return detailViewControllerVC
    }


// 遷移側
let detailVC = DetailViewController.make(url: provider.accessList[indexPath.row].url)
self.navigationController?.pushViewController(detailVC, animated: true)


バージョンごと
if #available(iOS 10.0, *) {
                // iOS10以降の場合
            } else {
                // iOS9以前の場合
            }


メインスレッドで実行（非同期中にかく）
DispatchQueue.main.async {
        // Main Threadで実行することをかく
    }


クロージャー
ハンドラー
completion: (()-> Void)?
引数あり（_を入れることで引数名の表示は省略される）
completion: @escaping ((_ restData: [RestData], _ error: Error?) -> ())
デフォルト引数あり（引数入力自体を省略できる）
completionHandler: ((Any) -> ())? = nil

日付
Date変換

//MARK: - Helper
    /// 文字列⇒日付変換
    ///
    /// - Parameter dateString: 日付（文字列）
    /// - Returns: 日付
    private func stringToDate(dateString: String) -> Date {
        let dateFormater = DateFormatter()
        dateFormater.locale = Locale(identifier: "ja_JP")
        dateFormater.dateFormat = "yyyy/MM/dd HH:mm:ss"
        return dateFormater.date(from: dateString) ?? Date()
    }
    
    /// 日付⇒文字列変換
    ///
    /// - Parameter date: 日付
    /// - Returns: 日付（文字列）
    private func dateToString(date: Date) -> String {
        let dateFormater = DateFormatter()
        dateFormater.locale = Locale(identifier: "ja_JP")
        dateFormater.dateFormat = "yyyy/MM/dd HH:mm:ss"
        return dateFormater.string(from: Date())
    }


// Error側をNSErrorも使えるように拡張
extension Error {
    fileprivate var nsError: NSError {
        return (self as NSError)
    }
}

ストリングファイルの使用
まず以下のURLに沿ってstrigfileを作る
https://qiita.com/simorgh3196/items/c9b04377dfa1425085c3

stringを拡張するクラスを用意
ローカライズ
クラス名：String+Localized

import Foundation

extension String {

    func localized() -> String {
        return NSLocalizedString(self, comment: "")
    }

}

使用法
呼び出す場所で
"stringfileでのkey".localized()

stringファイル内
"offlineAlertTitle" = "警告";

変数の型の種別を知る
targetView.isKind(of: 任意の型.self)
