Swift コードメモ

git 打ち消し線
~~ここが打消しされるよ~~

DispatchQueueの使い方
種類について（一部）
直列、メインスレッド
let queue = DispatchQueue.main
直列、サブスレッド
let queue = DispatchQueue(label: "jp.sample.queue")
並列、サブスレッド
let queue = DispatchQueue.global(qos: .default)
let queue = DispatchQueue(label: "jp.sample.queue", attributes: .concurrent)

正規表現でのパターンマッチ判定
public func isMatch(pattern: String) -> Bool {
        guard let expression = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) else { return false }
        let range = NSRange(location: 0, length: self.count)
        let mathes = expression.matches(in: self, options: .anchored, range: range)
        return mathes.count > 0
        
使用例
if string.isMatch(pattern: "[a-zA-Z0-9]+://") {}



正規表現でのパターンマッチングを管理するenum

enum Pattern: Int, CaseIterable {
    case scheme
    
    func match(string: String) -> [String] {
        let objcString = string as NSString
        let range = NSRange(location: 0, length: objcString.length)
        let expression = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)
        let matches = expression?.matches(
            in: string,
            options: .withoutAnchoringBounds,
            range: range
        )
        return matches?.compactMap({ return objcString.substring(with: $0.range) }) ?? []
    }
    
    private var pattern: String {
        switch self {
        case .scheme: return "[a-zA-Z0-9]+://[^ \\n]+"
        }
    }
    
}


文字列の前後の空白と改行を削除
word?.trimmingCharacters(in: .whitespacesAndNewlines)




extension String {
    /// 指定文字列を文章内から取り除く
    ///
    /// - Parameter text: 取り除く文字列
    /// - Returns: 処理結果
    func trim(text: String) -> String {
        return self.replacingOccurrences(of: text, with: "", options: .literal, range: nil)
    }
}


struct PhotoLibraryEntityをExtensionで子プロパティを定義する
（ネストを減らす）



tableviewの縦に動いた瞬間に横のスクロールをとる（visible,見えているテーブルビューの開始時）

XcodeProjectテンプレートの作り方

protcolはその人にしか、つけられないようにする（）




戻り値使わない
@discardableResult


UIColorカラーリテラル
#colorLiteral(red: 0.4274509804, green: 0.7568627451, blue: 0.6196078431, alpha: 1)


ステータスバー　statusbarの色変える（VCごとに設定）
 override var preferredStatusBarStyle: UIStatusBarStyle {
        return .lightContent
    }

BlurViewの単体は単純に曇りガラス
BlurViewのエフェクト付きの方はBlurの中のViewを透明などブラーに合わせた見た目に勝手に調整してくれる


fetchControllerのセクションとせる
セクションごとのオブジェクトの数
fetchController.sections![0].numberOfObjects
セクションごとのオブジェクト
fetchController.sections![0].objects


tableview in collection view
tableviewcell 内の collection view をstackviewで囲むとcell生成メソッドが走らない

アニメーションデリゲート（コントローラー側）
extension ListViewController: UIViewControllerTransitioningDelegate {
    
    func animationController(forPresented presented: UIViewController,
                             presenting: UIViewController,
                             source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        return CustomAnimator(duration: 0.5, isPresenting: true)
    }
    
    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        return CustomAnimator(duration: 0.5, isPresenting: false)
    }

}

２つのプロトコル準拠
Decodable & Encodable


画像ファイルの種類によって、ツールバーに入るボタンを動的に設定している（ボタン自体はストーリーボードの画面外にセットしてある）
if asset.mediaType == .video {
            toolbarItems = [favoriteButton, space, playButton, space, trashButton]
        } else {
            // In iOS, present both stills and Live Photos the same way, because
            // PHLivePhotoView provides the same gesture-based UI as in the Photos app.
            toolbarItems = [favoriteButton, space, trashButton]
        }
ツールバーのボタンの動的切り替え
https://qiita.com/_ha1f/items/6ae8ece70107f2944a78


navigationVCの子VCにてViewタッチでナビバーを閉じるアニメーション設定（viewのsubviewで別のタッチイベントがあるとそちらが優先される）
navigationController?.hidesBarsOnTap = true


ナビバーの表示/非表示のタイミングでviewの背景を変える
 override func viewWillLayoutSubviews() {
        let isNavigationBarHidden = navigationController?.isNavigationBarHidden ?? false
        view.backgroundColor = isNavigationBarHidden ? .black : .white
    }





インクリメントサーチ（UISearchBarデリゲート）
   func searchBar(_ searchBar: UISearchBar, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        DispatchQueue.global().asyncAfter(deadline: .now() + 0.1) {
            // 文字入力許可後0.1秒後に検索を開始する
            DispatchQueue.main.async {
                self.presenter.search(word: self.navigationItem.searchController?.searchBar.text)
            }
        }
        return true
    }

@testable import Data

Coredata
Predicateの複数指定
// 検索条件指定
            let searchTitlePredicate = NSPredicate(format: "title CONTAINS[c] %@", searchWord)
            let searchNamePredicate = NSPredicate(format: "speakerName CONTAINS[c] %@", searchWord)
            let searchDescriptionPredicate = NSPredicate(format: "descriptionText CONTAINS[c] %@", searchWord)
            
                        fetchRequest.predicate = NSCompoundPredicate(orPredicateWithSubpredicates: [searchTitlePredicate,
                                                                                                    searchNamePredicate,
                                                                                                    searchDescriptionPredicate])
            l
エンティティの全削除
/// 全件削除
    private func allDelete(entityName: String) {
        let context = CoreDataManager.shered.mainThreadContext()
        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: entityName)
        let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)
        try! context.execute(deleteRequest)
    }


Swiftにおけるclassとstructの使い分け
・カプセル化してプロパティを持ちたいとき・・・struct
・プロパティを持つ必要がない時やカプセル化として使用する必要がない時・・・class
https://cockscomb.hatenablog.com/entry/choosing-between-classes-and-structures


テーブルビューのスクロールビュー一番上まで
tableView.scrollToRow(at: IndexPath(row: 0, section: 0), at: .top, animated: false)


protcolをオプショナル（実装必須ではない）にする
// 各画面が必要に応じてデリゲートを受けられるようにオプショナル型で宣言
@objc public protocol CoreDataManagerDelegate: class {
    /// 全ての記事情報を取得
    @objc optional func fetchedAllArticleItems(_ items: [ArticleItem])
    /// カテゴリー指定で記事情報を取得
    @objc optional func fetchedArticleItemsByCategory(_ items: [ArticleItem])
    /// 記事情報の取得に失敗
    func failedFetch(error: Error)
    // TODO: - 各種処理のエラーハンドリングが必要
}


スクロールを検知する方法（上に、下に）
1. Viewでスクロールの開始位置と開始タイミングをデリゲートでキャッチ
func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
        // スクロールごとに開始ポイントをプロパティに保持する(    var beginScrollPoint = CGPoint(x: 0, y: 0)
)
        presenter.beginScrollPoint = scrollView.contentOffset
    }
    
func scrollViewDidScroll(_ scrollView: UIScrollView) {
        presenter.didScroll(contentOffsetY: scrollView.contentOffset.y)
    }


2. Presenterで上にスクロールor下スクロールを判定（上で取った開始位置を渡してあげる）
 /// スクロールを監視
    ///
    /// - Parameter contentOffsetY: Y軸のスクロール値
    func didScroll(contentOffsetY: CGFloat) {
// プロトコルを着火してView側で何かする（Bool値を渡している）
        interface?.searchBarIsHidden(beginScrollPoint.y < contentOffsetY)
    }
例：
presenter側
  /// サーチバーの表示非表示を切り替える
    func searchBarIsHidden(_ isHidden: Bool)
view側
    func searchBarIsHidden(_ isHidden: Bool) {
//        navigationItem.hidesSearchBarWhenScrolling = isHidden
    }


文字を入れた場合のサイズをとる
 let categrySize = presenter.categoryList[indexPath.row].title.size(withAttributes: [NSAttributedString.Key.font: UIFont.systemFont(ofSize: 15.0)])


サーチバーをナビばーに入れる
 let searchController = UISearchController(searchResultsController: nil)
        navigationItem.searchController = searchController
        searchController.searchResultsUpdater = self
        // 検索バーの下の空間を検索結果か検索候補どちらにするかを決める（true: 検索候補、false: 検索結果）
        searchController.obscuresBackgroundDuringPresentation = false
        // UISearchControllerをUINavigationItemのsearchControllerプロパティにセットする。
        // trueだとスクロールした時にSearchBarを隠す（デフォルトはtrue）
        // falseだとスクロール位置に関係なく常にSearchBarが表示される
        navigationItem.hidesSearchBarWhenScrolling = true


largetitleの色変更
UINavigationBar.appearance（）。largeTitleTextAttributes = 
    [NSAttributedStringKey.foregroundColor：UIColor.green]


  /// PullToRefresh時のアクション
    @objc func pullToRefresh(sender: UIRefreshControl) {
        interface?.startIndicator()
        datasource.callApi(type: .droidAPI(parameters: [:]))
    }

PullToRefresh プル
let refreshControl = UIRefreshControl()
            refreshControl.tintColor = .white
            refreshControl.addTarget(presenter,
                                     action: #selector(presenter.pullToRefresh(sender:)),
                                     for: .valueChanged)
            tableView.refreshControl = refreshControl

タップしたテーブルビューの大きさを取得
let cellFrame = tableView.convert(tableView.rectForRow(at: indexPath),
                                          to: tableView.superview)

サブクラスのVCのステータスバーの色をセットする
class ThemeViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        setNeedsStatusBarAppearanceUpdate()
    }
    
    override var preferredStatusBarStyle: UIStatusBarStyle {
        return .lightContent
    }
    
}

ナビゲーションコントロラーの子の時はナビVCクラスを作って以下をoverrideする必要あり
override var childForStatusBarStyle: UIViewController? {
        return self.visibleViewController
    }
    
    override var childForStatusBarHidden: UIViewController? {
        return self.visibleViewController
    }


self のアンラップ
guard let `self` = self else { return }
マルチスレッドで CoreDataのオブジェクトを扱えるようにするにはスレッドごとに NSManageObjectContextを用意する必要があります。

throws ・・・do catch以外の要素を使うときはメソッド自体をthrowsにする（ifで対応できる）

delegateをweakで持てないのはprotocolがclass対象になっていないから

@IBOutlet weak var restrantListTableView: UITableView! {
        didSet {
            // テーブルビューの各種設定
        // デリゲート
            restrantListTableView.delegate = self
        // データソース
            restrantListTableView.dataSource = self
        // カスタムセルの登録
            restrantListTableView.register(UINib(nibName: RestrantInfoCell.identifier, bundle: nil),
                                           forCellReuseIdentifier: RestrantInfoCell.identifier)
        // カスタムフッター用セルの登録
            restrantListTableView.register(UINib(nibName: ReloadView.identifier, bundle: nil),
                                           forCellReuseIdentifier: ReloadView.identifier)
        // カスタムフッターの登録（上記で用意したセルを当てる）
            if let reloadView = restrantListTableView.dequeueReusableCell(withIdentifier: ReloadView.identifier) as? ReloadView {
                reloadView.indicator.isHidden = true
                restrantListTableView.tableFooterView = reloadView
// 一旦高さ0で隠しておく
                restrantListTableView.tableFooterView?.frame.size.height = 0
            }
        }
    }
    

カスタムフッターの使い方
上記で登録してある前提で

let reloadView = self.restrantListTableView.tableFooterView as! ReloadView
reloadView.indicator.isHidden = isHidden
// 高さを戻して見えるようにする
reloadView.frame.size.height = isHidden ? 0 : 50


// それぞれの準拠元で柔軟的に型を決定できる値（protcol版ジェネリクス）
    associatedtype ViewObject
    // Presenterクラス側でViewクラスを保持する用propatie
    // デフォルト実装で、自動的に渡されたViewクラスをPresenterクラスのinterface変数(protcol)にセットする
    var interface: ViewObject? { get set }

 /// lacalのjsonファイルのpathを取得
    ///
    /// - Parameter fileName: ファイル名
    /// - Returns: jsonファイルのpath(失敗の場合はnil)
    func getLocalJsonFilePath(fileName: String) -> String? {
        return Bundle.main.path(forResource: fileName, ofType: "json")
    }

/// TestProjectに置いてあるlacalのjsonファイルのpathを取得
    ///
    /// - Parameter fileName: ファイル名
    /// - Returns: jsonファイルのpath(失敗の場合はnil)
    func getLocalJsonFilePathFromTestPJ(fileName: String) -> String? {
        return Bundle(for: type(of: self)).path(forResource: fileName, ofType: "json")
    }

@testable 
テスト用、アクセスレベルinternalまでのデータにアクセスできるようになる

MVPとMVVMの違い
MVP・・・ViewとPresenterが参照しあう（お互いに保持する、Presenter側はプロトコル準拠したViewを保持）
MVVM・・・ViewとPresenterがお互いを知らない（保持しない）
→ View側でPresenter側のプロパティを監視する（プロパティ名だけで繋がるため、お互いに保持しない、疎結合になるためテストしやすい）


Emmbedframeworkの導入
/// 外部からinitできるようアクセスレベルを変更（必須）
    public init() {}


cocoaPodsKeyをいれた後の呼び出し方
private let apiAccessKey = MVPAPISampleXcodeprojKeys().gurunaviApiKey

DI・・・初期値を持たせて初期化する（期待の結果を持たせてインスタンスを作ること）

presenterはweakでもつ・・・VCから参照する、presenterからVCを参照する相互参照から

associatedtype 変数名・・・プロトコル内で使えるジェネリクス（presentterのinitをジェネリクス化　base interfice）


NVActivityIndicatorViewの使い方
デフォルトのインジケーターで良い場合（シングルトンであらかじめ定義されているデフォルトをそのまま使う、文字のセットはできる）
インポート
スタート
NVActivityIndicatorPresenter.sharedInstance.startAnimating(ActivityData(message: "データ取得中"))
ストップ
NVActivityIndicatorPresenter.sharedInstance.stopAnimating()

全部いじれるのはNVActivityIndicatorViewをインスタンス化してプロパティでもつ方法

使いやすい方法
protcol（NVActivityIndicatorViewable）を準拠するとstart,stopが使える、タイプも変えれる

codableも持ちプロパティに初期値を与えれば空で定義できる
protcolのデフォルト実装を型指定で行う
extension protcolName where Self: UITableViewCell(指定する型) {
// 何か
}


ナビバーのタイトルの更新
self.navigationItem.title = title

ナビバーの戻るボタンのデフォルトタイトルを消す
storyboradのnavigationItemsのbackbuttonに空白入れる

Dispatch queue
また、DispathcQueue自体に、Serial、Concurrent、mainの３種類が存在します。
それぞれ以下のように分類されています（公式ドキュメントも参照）。

Serial：登録したタスクを、同時並行ではなく、登録した順に実行
作り方：自身でラベル生成
Concurrent：登録したタスクを、同時並行で実行
デフォルトで用意されてqueue使う（global等）

main：メインのUIスレッドでの実行。主にタスク内でUI操作を行う時などで使用


CoreDataのロールバック（保存結果戻し）
managedContext.rollback()

URL UIImage 変換
static func getImage(urlString: String) -> UIImage? {
        do {
            guard let url = URL(string: urlString) else { return nil }
            let imageData = try Data(contentsOf: url, options: .mappedIfSafe)
            return UIImage(data: imageData) ?? nil
        } catch {
            return nil
        }
    }

 static func getImage(urlString: String) -> UIImage {
        do {
            guard let url = URL(string: urlString) else { return UIImage(named: "defaultImage")! }
            let imageData = try Data(contentsOf: url, options: .mappedIfSafe)
            return UIImage(data: imageData) ?? UIImage(named: "defaultImage")!
        } catch {
            return UIImage(named: "defaultImage")!
        }
    }



キーボード設定
enablesReturnKeyAutomatically：trueなら未入力のときリターンきーを無効にする、デフォルトfalse
ローカルファイルのpath取得
 guard let filePath = Bundle.main.path(forResource: "UserData-Sample", ofType: "json") else {
            fatalError("json is not found in main Bundle.")
        }

配列　指定した方以外の値を削除する　取り除く
flatMap(返り値使用しない)compactMap(返り値使用する)
nil、optional削除
["1", "2", "3"].map { Int($0) } // → [Optiona(1), Optiona(2), Optiona(3)]
["1", "2", "3"].flatMap { Int($0) } // → [1, 2, 3]
形違い削除
["1", "2", "string", "3"].map { Int($0) } // → [Optiona(1), Optiona(2), nil, Optiona(3)]
["1", "2", "string", "3"].flatMap { Int($0) } // → [1, 2, 3]


lazy var プロパティ名 = 変数またはメソッド
レイジープロパティとは
レイジープロパティ（lazy stored property）とは、参照されるときに初めて初期値が設定されるプロパティのことである。
レイジープロパティは以下のように定義する。インスタンス生成後に値を変更するプロパティなので定数（let）で宣言することはできない。

セルのレイアウト
複数の制約のONOFFを使い分ける場合は遠い方から設定
どっちを優先するかを決めるのは、Content Hugging Priority
中からの力が弱く潰れるときは　Content Compression Resistance Priority を強くする
２つのラベルは伸ばしたい方から制約をきめるその後、Content Hugging Priorityをいじる

値を代入する	set…
値を取得する	get…
計算する	calculate…
変換する	convert…to…
真偽値を返す	is…

let ddd: (型A && 型B) で２種のクラスを持った変数を宣言できる（プロトコルをつけたクラスなど）

今後学習
rakeコマンドの設定をする

enmuにプロパティを持たせるには、enumu内で定義して varで作って　リターンする
enum・・・固定の値
struct・・・使い回す値
defer{}
処理の中が全部終わった後に実行される

initの時点でのdidset,willsetは呼ばれない

cocoapods-key(.envファイルに書き出す) 開発者個人の情報はそこに書く


メモリーリークが出た場合
xcode > open tool > instruments > link


簡単な確認法
ブレイクで止めて左下の!ボタンでメモリーリークしている箇所だけ出せる


テーブルビューのデリゲートクラスで、スクロールで画面外のセルに対して、アクションを提示できる
セルの作成はしないため、はめるようのパーツの用意などをしておける（画像など）
ただ、セルクラスで初めてダウンロードする場合は、意味ない、このデリゲートであらかじめ、ダウンロードした画像を配列として用意しておくか、ローカルのDBに入れるなどして持っておくと
ダウンロードの手間と時間を省ける
prefetchDataSource


デリゲートはプロトコルをつないでいくデザインパターン（引数、戻り値が固定のため、ロジックに左右されない）
protcolは準拠していれば、絶対にprotcolメソッドを書かないといけないが、
extentionでデフォルトメソッド内容を書いておけば書かなくてもよくなる（optional的なやつ）
デフォルト実装書いてあれば、準拠先からselfのメソッドとしてデフォルトも呼べるし、準拠先に同名のメソッドを定義すれば、そっちが呼ばれる（デフォルトに勝てる）

control+command+R でビルドせずにアプリを再起動できる

プロトコルに準拠したコントローラーの書き方（どっちのメソッドも使える）
vc: AreaListInterface & UIViewController

add subview ・・・配列の一番後ろに入れる
insert subview・・・指定したところに入れる（対象は順番でも指定のviewの後ろとかでもいける）

通知説明
http://xyk.hatenablog.com/entry/2016/11/02/180204
Xcode で Today Extension のデバッグ時にブレークポイントを有効にする方法
http://www.minimalab.com/blog/2014/09/27/today-extension-degug/

プッシュ通知のデバイストークンの取得方
extension String {
    public init(deviceToken: Data) {
        self = deviceToken.map { String(format: "%.2hhx", $0) }.joined()
    }
}

/// 通知受け取り時にextensionでtoken生成
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data!) {
    let token = String(deviceToken: deviceToken)
}

一定時間後に処理を実行する方法
DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
    // 0.5秒後に実行したい処理
}

値渡し、戻る
// 遷移元のVCを取得して値渡し
        guard
            let navigationController = self.navigationController,
            let memoListController = navigationController.viewControllers[navigationController.viewControllers.count - 2] as? MemoListController else {
            // 何もせずに戻る
            self.navigationController?.popViewController(animated: true)
            return
        }
        // 結果をリスト画面に渡して戻る
        memoListController.databaseActionType = type
        memoListController.databaseError = error
        
        self.navigationController?.popViewController(animated: true)



応用で指定の文字列を削除した上で文字列を返すことができるよ！！
/// 文字列が「空文字orスペースのみ」でないかを判定
    ///
    /// - Parameter title: チェックする文字列
    /// - Returns: true: 空文字orスペースのみ、false: スペースではないテキストが1文字以上入っている
    private func hasText(title: String) -> Bool {
        var checkTitle = title
        while true {
            guard let range = checkTitle.range(of: " ") else {
                break
            }
            checkTitle.removeSubrange(range)
        }
        return checkTitle.isEmpty
    }

public extension String {
    /// 文字列を”１行目”と”２行目以降”に分ける
    ///
    /// - 2行以上の文章　= [１行目, それ以降の文章]
    /// - 1行の文章　= [１行目]
    /// - nil(ありえない)　= []
    func divideFirstLines() -> [String] {
        var lines: [String] = self.components(separatedBy: .newlines)
        guard lines.count >= 1 else { return [] }
        let firstLine = lines[0]
        lines.remove(at: 0)
        guard lines.count >= 1 else { return [firstLine] }
        let otherLine = lines.joined(separator: "\n")
        return [firstLine, otherLine]
    }
}



値渡しでもどる
 // 遷移元のVCを取得して値渡し
        guard
            let navigationController = self.navigationController,
            let memoListController = navigationController.viewControllers[navigationController.viewControllers.count - 2] as? MemoListController else {
            // 普通に戻る
            self.navigationController?.popViewController(animated: true)
            return
        }
        // 結果をリスト画面に渡して戻る
        memoListController.databaseActionType = type
        memoListController.databaseError = error
        
        self.navigationController?.popViewController(animated: true)


排列内のインデックスを順に取得
for (index, value) in memoListCopy.enumerated() {}



ハンドラーhandler
static func update(model: Memo, completion: ((ActionType, Error?) -> Void)) {}

// stringでメソッド名を指定して呼び出す（呼び出しは@objcをつける）
self.perform(Selector("メソッド名"))
// 呼び出しメソッド
@objc private func transitTeamAViewController() {
        //TODO  : チームA
    }

ハンドラー
プロトコルprotcolにデフォルト引数を持たせるときはextension（引数を省略できる、渡しても渡さなくても良い）
extension ProtocolName {
    func errorAlert(message: String, completionHandler: ((Any) -> ())? = nil) {
        let alert = UIAlertController(title: "エラー", message: message, preferredStyle: .alert)
        let alertAction = UIAlertAction(title: "OK", style: .default, handler: completionHandler)
        alert.addAction(alertAction)
        AlertManager.present(alert: alert)
//        self.present(alert, animated: true) // UIViewController自体を持っていない
    }
}

アクセス修飾子

getterもsetterも公開するプロパティ
public var option: Option

getterのみ公開するプロパティ（取得はできるが、変更はできない）
public private(set) var view: CustomView


// ループ処理を抜けるためのラベルをforEachの場合も使えるようにする
extension Array {
    func forEachWithBreak(operation: (Element, () -> ()) -> ()){
        var loop = true
        func fail(){
            loop = false
        }
        label: for item in self {
            operation(item, fail)
            if loop == false {
                break label
            }
        }
    }
}


Codableの使い方

// 単一
 do {
      let decoder = JSONDecoder()
      let response = try decoder.decode(codableモデルクラス.self, from: jsonData)
    } catch let error {
      print("error: \(error.localizedDescription)")
    }

// 配列
do {
     let decoder = JSONDecoder()
     let tweetData = try decoder.decode([codableモデルクラス配列用].self, from: jsonData)
    } catch let error {
      print("error: \(error.localizedDescription)")
    }


修飾子に関して

メソッドにも変数にも、アクセス制限はつけれる

fileprivate
同一ファイル内であればアクセスできる

private
メソッドならでないとアクセスできない（一番硬い）

extension（クラス拡張のこと、デリゲートでよく使う）



メソッドは


structはプロパティを持ったプロパティ
Constrains.ToolBar. addFolderButton みたいに使える
struct Constrains {

    /// ツーバーに表示する文字列
    struct ToolBar {
        static let addFolderButton = "addFolderButton".localized()
        static let addTaskButton = "addTaskButton".localized()
        static let deleteAllButton = "deleteAllButton".localized()
    }

テーブルビュー
スワイプ での変更モードの取得　感知（tableviewdelegate）
 func tableView(_ tableView: UITableView, willBeginEditingRowAt indexPath: IndexPath) {
        "変更開始"
    }
    
    func tableView(_ tableView: UITableView, didEndEditingRowAt indexPath: IndexPath?) {
        "変更完了"
    }
    

テーブルビュー　セルがない部分のセパレート線を消す（空行）余分、余白
self.tableView.tableFooterView = UIView()

テーブルビュー　削除　アニメーション付き
 // アニメーション付きで削除
// データソース側の要素を削除後（DBの方も）
self.dataSource.memoList.remove(at: 0)
// 以下のコマンドで削除結果をアニメーション付きで反映
self.memoList.deleteRows(at: [IndexPath(row: 形したrow, section: 消したrowのセクション)], with: .fade)

// 全削除をアニメーションでやる場合
 // アニメーション付きで削除
            for _ in self.dataSource.memoList {
                self.dataSource.memoList.remove(at: 0)
                self.memoList.deleteRows(at: [IndexPath(row: 0, section: 0)], with: .fade)
            }
            self.memoList.reloadData() // 編集で単数削除選択時に全削除すると固まる問題への対応





テーブルビューの編集ボタンアクション
作成
navigationItem.rightBarButtonItem = editButtonItem
モード切り替え
override func setEditing(_ editing: Bool, animated: Bool) {
        super.setEditing(editing, animated: animated)
        memoList.isEditing = editing
    }

オリジナルのタイトルつけるとき
private func setupToolBar(isEditing: Bool) {
        editButton.title = isEditing ?
            Constrains.ToolBar.deleteAllButton : Constrains.ToolBar.addFolderButton
    }

テーブルビュー削除アクション(tableviewDataSource)
 func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
        if editingStyle == .delete {
            self.delegate?.delete(index: indexPath.row)
        }
    }


テーブルビューの選択状態を戻す
override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        if let indexPathForSelectedRow = tableView.indexPathForSelectedRow {
            tableView.deselectRow(at: indexPathForSelectedRow, animated: true)
        }
    }

 // スクロールを上まで戻す
        self.jobOfferListTableView.scrollToRow(at: IndexPath(row: 0, section: 0), at: .top, animated: false)

その値があるのかどうかを確認する方法
guard let ~~~ {
YESの場合の処理
}

pubic
importなどで繋がっていれば参照できるアクセス権限

プロトコル
デリゲートの定義（先頭は大文字で）
protocol Hogedele: class {
    func failedThen()
}

デリゲートプロパティの用意
weak var loadable: hogedele?

デリゲートメソッドの呼び出し
loadable?.failedThen()


コメント
// MARK: - LifeCycle Methods

// MARK: - SetUp Methods

// MARK: - Private Methods

初期化　？
？　＝　alloc initをしていること
初期値があるときは、何かを定義する

! ＝ ?(alloc init)状態から、初めて値が入った時につける
初期値が入っている場合はつけない


アクセス修飾子
制限緩い
open：モジュール外からもアクセスできる。 一番ゆるいアクセスコントロール。 新規追加✨
public：モジュール外からもアクセスできる。 サブクラス化されない。 overrideできない。
internal：モジュール内ならアクセスできる。 何も書かないとコレになる。（デフォルト）
fileprivate：文字通りファイル内ならアクセスできる。 新規追加✨
private：クラスなど宣言内でしかアクセスできない。
制限厳しい


letもvarも先頭小文字

enum内の要素も小文字



urlとdateの命名（URL型かString型かを命名ではっきりさせる）
var thumbnailURL: URL
var imageURLString: String
var lastUpdateDate: Date
var birthdayString: String


if文の書き方　（）がいらない
if names.isEmpty {
    ...
}

コールバックやinitの時だけselfをつける（wselfなどは必要ない）


モダンな書き方
Array・dictionary
var names = [String]()
var jsonDic = [String: AnyObject]()

早期リターンチェック
guard hogehoge else {
    return
}



アラートの表示（ヘルパー利用）
func showAlert(message: String, handler: ((UIAlertAction) -> Void)? = nil) {
        let alert = AlertHelper.alert(message: message, rightButtonAction: handler)
        self.present(alert, animated: true, completion: nil)
    }


戻る処理
self.dismiss(animated: true, completion: nil)

self.navigationController?.popViewController(animated: true)

初回画面まで戻る
self.navigationController?.popToRootViewController(animated: true)


プリント
print
print("中身は\(url)")
:-1: Build input file cannot be found: '/Users/kawaharadai/Library/Developer/Xcode/DerivedData/Stationery-Project-bncjtwhcbynhjwebrmshnajrlmnh/Build/Products/Debug-iphonesimulator/Stationery-Project.app/PlugIns/Stationery-ProjectTests.xctest/Stationery-ProjectTests'

他のバージョンで使う場合のメモ
 // TODO: デザイン確定後修正する

あとで対応予定で残す場合
// FIXME: testJSが不要になったら削除する

シュミレーターのデータ保存先確認・保存場所
 let documentDirPath = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.documentDirectory, FileManager.SearchPathDomainMask.userDomainMask, true)
        print(documentDirPath)

cache.dbを消す時
URLCache.shared.removeAllCachedResponses()

webviewで表示したもののアプリケーションキャッシュ・ブラウザキャッシュを消す
WKWebsiteDataStore.default().removeData(ofTypes: WKWebsiteDataStore.allWebsiteDataTypes(),
                                                modifiedSince: Date(timeIntervalSince1970: 0)) {
                                                    print("remove all cache.")
        }


base64 エンコード、デコード
https://qiita.com/tenten0213/items/6ac8682e3a7e3b378167


NetWorkcacheのみ消せた
WKWebsiteDataTypeDiskCache

/Library/Cookiesを消せた
WKWebsiteDataTypeCookies

どこが消えたかわからない
WKWebsiteDataTypeSessionStorage

以下のアプリケーションキャッシュを消せた
/Library/Caches/com.stv.iQUICK/WebKit/OfflineWebApplicationCache
WKWebsiteDataTypeOfflineWebApplicationCache

NetWorkcacheとWKWebsiteDataTypeOfflineWebApplicationCacheの両方を消せるが、
Web SQL.dbも消えてしまう
 WKWebsiteDataStore.default().removeData(ofTypes: WKWebsiteDataStore.allWebsiteDataTypes(),
                                                modifiedSince: Date(timeIntervalSince1970: 0)) {
        }


リテラルコーディング（＋奥寺さん資料）
 #if FOR_ADMIN
            let text = "admin"
        #elseif FOR_USER
            let text = "user"
        #else
            let text = "dev"
        #endif
        print(text)


アプリの設定ページを編集する
https://qiita.com/akatsuki174/items/392cb3be619fabfa4608
https://github.com/stv-ekushida/ios-licence-auto-make-demo
https://qiita.com/mono0926/items/973752b69c881e00c507#_reference-cad5bf9a515fddc13848


nilでないチェック
openRequestURL != ""
ではなく
!openRequestURL.isEmpty

Bool値の宣言
Bool()ではなく初めからfalseを宣言（初期値がfalseのため）
var notExistURL = false


アプリを強制的に落とす
fatalError("スキームが存在しない")


swiftでFMDB
https://qiita.com/s_emoto/items/5488667478c0339b4e83

podでライブラリのエラーを無視する
pod〜〜の上に
inhibit_all_warnings!
/Users/kawaharadai/xcode sorcefile/sample/DrawerMenu-Sample/DrawerMenu-Sample/Other/Bridging-Header.h

staticをつければ、どこからでも呼べる（クラスメソッド的なやつ）
finalは呼ばなければ絶対にアクセスできないクラス

// 配列の中の要素全体に対して、一つ一つをFolderモデル型に変換している（{}の中であれば$0を一つの要素として見れる）
// 戻り値が必要ないときはmapではなく、forEachを使う
objects.map { Folder(value: $0) }

取り出したものを入れる変数は、Arrayかdic
詳しい使い方は
https://qiita.com/motokiee/items/cf83b22cb34921580a52

for文
(0..<10).map {//処理}

for i in 0..<10 {
    //処理
}

for文内での条件ずけ
条件が複数の時は、fileterで絞ってしまう
for validSite in validSiteList where validSite.path.isEmpty {}


配列　Array
中身の文字列を結合
testArray.joined()


// ピンチアクションの登録
let pinchGesture = UIPinchGestureRecognizer(target: self, action: nil)
self.view.addGestureRecognizer(pinchGesture)

// wkwebviewへのピンチアクションの登録（デフォルトではNO）
http://ioscake.com/wkwebview-equivalent-for-uiwebviews-scalespagetofit.html


ピンチが可能なWKWebView作成
 let jsString = "var meta = document.createElement('meta');" +
            "meta.setAttribute('name', 'viewport');" +
            "meta.setAttribute('content', 'width=device-width'); " +
        "document.getElementsByTagName('head')[0].appendChild(meta);"
        
        let userScript = WKUserScript(source: jsString, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
        
        let wkUController = WKUserContentController()
        wkUController.addUserScript(userScript)
        
        let wkWebConfig = WKWebViewConfiguration()
        wkWebConfig.userContentController = wkUController
        
// ピンチがいらないときは上記は消す
//        let webConfiguration = WKWebViewConfiguration()
        webView = WKWebView(frame: .zero, configuration: wkWebConfig)
        webView?.uiDelegate = self
        webView?.navigationDelegate = self
        webView?.allowsBackForwardNavigationGestures = true
        
        useragent(webview: webView)
        
        view = webView



ユーザーデフォ
userdefault

保存
UserDefaults.standard.set(jsonDataEncrypted, forKey: "settingFile")

取得
let jsonDataEncrypted = UserDefaults.standard.data(forKey: "settingFile"),


string、url変換
String(contentsOf: URL)
URL(string: String)

テーブルビューメソッド
// MARK: - UITableViewDataSource Methods
extension ModeListProvider: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return modeListData.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: MenuViewCell.identifier, for: indexPath) as? MenuViewCell else {
            fatalError("cell is nil")
        }
        return cell
    }}

テーブル　必須
import UIKit

protocol FolderListDataSourceDelegate {
    func delete(index: Int)
}

class FolderListDataSource: NSObject {
    var folderList: [Folder] = []
    var delegate: FolderListDataSourceDelegate?
}

extension FolderListDataSource: UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return self.folderList.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: FolderListCell.identifier, for: indexPath) as? FolderListCell else {
            fatalError("cell is nil")
        }
        return cell
    }
    
    /// 削除のみ
    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
        if editingStyle == .delete {
            self.delegate?.delete(index: indexPath.row)
        }
    }
}


テーブルセル nibの登録(setup時) セル登録
self.folderList.register(UINib(nibName: FolderListCell.identifier, bundle: nil),
                                 forCellReuseIdentifier: FolderListCell.identifier)

セルクラスメソッド(cell)
自身のidentifierを返す
static var identifier: String {
        return String(describing: self)
    }


自信のnibを返す（xibの登録時に呼ぶ、上と一緒に使う）
static func nib() -> UINib {
        return UINib(nibName: identifier, bundle: nil)
    }
    


/// NSDataのフォーマットを変更
    private func dateFormat(date: NSDate) -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy/MM/dd HH:mm"
        return dateFormatter.string(from: date as Date)
    }
    

// ローカルのJSONをストリングで出力
※ pathの作成でnilになる場合は、「let testBundle = Bundle(for: type(of: self))」を試す
 guard let path = Bundle.main.path(forResource: "btnu_custom_sample2", ofType: "json") else {
                    fatalError("json is not found in main Bundle.")
                }
                
                do {
                     let jsonData = try Data(contentsOf: URL(fileURLWithPath: path))
                    guard let jsonDataString = String(data: jsonData, encoding: .utf8) else {
                        print("変換失敗")
                        return
                    }


エラーして中断
fatalError("TaskListViewController is nil.")


オートレイアウト（コードで）
    private func setConstraint(view: UIView) {
        
//        let statusBarHeight = UIApplication.shared.statusBarFrame.height
        
        view.translatesAutoresizingMaskIntoConstraints = true
        
        let width = NSLayoutConstraint(item: view,
                                       attribute: .width,
                                       relatedBy: .equal,
                                       toItem: self.view,
                                       attribute: .width,
                                       multiplier: 1.0,
                                       constant: 0)
        
        let height = NSLayoutConstraint(item: view,
                                        attribute: .height,
                                        relatedBy: .equal,
                                        toItem: self.view,
                                        attribute: .height,
                                        multiplier: 1.0,
                                        constant: 0)
        
        let xPosition = NSLayoutConstraint(item: view,
                                           attribute: .centerX,
                                           relatedBy: .equal,
                                           toItem: self.view,
                                           attribute: .centerX,
                                           multiplier: 1.0,
                                           constant: 0)
        
        let yPosition = NSLayoutConstraint(item: view,
                                           attribute: .centerY,
                                           relatedBy: .equal,
                                           toItem: self.view,
                                           attribute: .centerY,
                                           multiplier: 1.0,
                                           constant: 30)
        
        let constraints = [width, height, xPosition, yPosition]
        
        view.addConstraints(constraints)
    }


データ型　→ string
guard let jsonString = String(data: jsonData, encoding: .utf8) else {
                    return
                }
                


オブジェクトマッパー
objectmapper

guard let jsonString = String(data: jsonData, encoding: .utf8) else {
            jsonDataError(useCache: jsonClient.useCache)
            return
        }
        
let mapJsonString = Mapper<SettingFileResponse>().map(JSONString: jsonString)



画面遷移
1
guard let webViewController = UIStoryboard(name: "WebView", bundle: nil)
            .instantiateInitialViewController() as? WebViewController else {
                return
        }
        
        webViewController.selectConfigURL = requestConfigURL
        
        present(webViewController, animated: true, completion: nil)



2
 let infoVC = InfomationPageViewController.make(accessURL: AccessInfomation.teamOfService.rawValue)
        self.navigationController?.pushViewController(infoVC, animated: true)


// 遷移先に用意するもの
 class func make(followerId: String?) -> FollowerPageViewController {
        let vcName = FollowerPageViewController.className
        guard let followerVC = UIStoryboard.viewController(
            storyboardName: vcName, identifier: vcName) as? FollowerPageViewController else {
                fatalError("FollowerPageViewController is nil.")
        }
        followerVC.followerId = followerId
        return followerVC
    }




並列処理
非同期処理
// サブスレッドで実行
DispatchQueue.global(qos: .default).async {
  // サブスレッド(バックグラウンド)で実行する方を書く 
    DispatchQueue.main.async {
        // Main Threadで実行する
    }
}


画面外タップでキーボードとじる
@IBAction func tapBackground(_ sender: Any) {
        self.view.endEditing(true)
    }


キーボードの出し入れのタイミングで画面をあげる　隠れないようにする
 /// キーボードの出し入れのタイミングの通知を登録
    private func registKeyboardNotification() {
        let notification = NotificationCenter.default
        notification.addObserver(self, selector: #selector(self.keyboardWillShow(notification:)), name: UIResponder.keyboardWillShowNotification, object: nil)
        notification.addObserver(self, selector: #selector(self.keyboardWillHide(notification:)), name: UIResponder.keyboardWillHideNotification, object: nil)
    }


/// キーボードが表示されたときの処理
    ///
    /// - Parameter notification: 通知情報
    @objc func keyboardWillShow(notification: Notification) {
        let rect = (notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue
        let duration = notification.userInfo?[UIResponder.keyboardAnimationDurationUserInfoKey] as? Double
        UIView.animate(withDuration: duration!,
                       animations: { [weak self] () in
                        let transform = CGAffineTransform(translationX: 0,
                                                          y: -(rect?.size.height)!)
                        self?.view.transform = transform
                        
        })
    }
    
    /// キーボードが非表示されたときの処理
    ///
    /// - Parameter notification: 通知情報
    @objc func keyboardWillHide(notification: Notification) {
        let duration = notification.userInfo?[UIResponder.keyboardAnimationCurveUserInfoKey] as? Double
        UIView.animate(withDuration: duration!,
                       animations: { [weak self] () in
                        self?.view.transform = CGAffineTransform.identity
        })
    }



enterpreice


コードでオートレイアウト
view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "H:|[v0]|",
                                                           options: NSLayoutFormatOptions(),
                                                           metrics: nil,
                                                           views: ["v0": webView ?? WKWebView()]))
        view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "V:|-20-[v0]|",
                                                           options: NSLayoutFormatOptions(),
                                                           metrics: nil,
                                                           views: ["v0": webView ?? WKWebView()]))


テーブルビュー関連
// テーブルビュー：セクションヘッダーの高さ変更
    func tableView(_ tableView: UITableView,
                   heightForHeaderInSection section: Int) -> CGFloat {
        return modeListHeaderSize
    }
    // テーブルビュー：セルの高さ
    func tableView(_ tableView: UITableView,
                   heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 100
    }
    
    // テーブルビュー：ヘッダーアレンジ
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        
        let headerView = UIView(frame: CGRect(x: 0,
                                              y: 0,
                                              width: tableView.frame.width,
                                              height: modeListHeaderSize))
        
        // 背景色
        headerView.backgroundColor = UIColor.black

        let titleLabel = UILabel()
        titleLabel.frame = CGRect(x: 20,
                                  y: 0,
                                  width: headerView.frame.width,
                                  height: headerView.frame.height)
        
        // 文字位置
        titleLabel.textAlignment = .left

        // 文字サイズ
        titleLabel.font = UIFont.boldSystemFont(ofSize: 25)

        // 文字色
        titleLabel.textColor = UIColor.white

        // 表示される文字
        titleLabel.text = "起動するアプリケーションを選択してください。"
        
        headerView.addSubview(titleLabel)
        
        return headerView
}
    
    // テーブルビュー：タップ時の処理
    func tableView(_ tableView: UITableView,
                   didSelectRowAt indexPath: IndexPath) {
        UserDefaults.standard.set(indexPath.row, forKey: "selectConfigURLNamber")
        transionScreen(requestConfigURL: self.provider.modeDataList[indexPath.row])
    }




回してStringからURLにする

guard let url = URL(string: "何かしらのURL") else {
                            self.userProfileImage.image = #imageLiteral(resourceName: "setting_user_icon")
                            return
                        }
                        self.userProfileImage.kf.setImage(with: url)


画面サイズ
let width = UIScreen.main.bounds.size.width
let height = UIScreen.main.bounds.size.height


コードでボタン作る

private func createBackButton() {
        
        let screenWidth: CGFloat = self.view.frame.width
        let screenHeight: CGFloat = self.view.frame.height
        
        let backButton = UIButton()
        
        backButton.frame = CGRect(x: screenWidth * 0.09, y: screenHeight * 0.03,
                                  width: screenWidth * 0.1, height: 60)
        
        backButton.setTitle("back", for: UIControlState.normal)
        
        backButton.titleLabel?.font = UIFont.boldSystemFont(ofSize: 30)
        
        backButton.setTitleColor(UIColor.buttonTitleNomal, for: .normal)
        backButton.setTitleColor(UIColor.buttonTitleHilight, for: .highlighted)
        backButton.backgroundColor = UIColor.buttonBackGround
        backButton.alpha = 0.9
        
        backButton.layer.masksToBounds = true
        backButton.layer.cornerRadius = 10
        backButton.layer.borderColor = UIColor.buttonBorder.cgColor
        backButton.layer.borderWidth = 1.0
        
        backButton.addTarget(self,
                             action: #selector(PDFWebViewController.buttonTapped(sender:)),
                             for: .touchUpInside)
        
        self.pdfWebView?.addSubview(backButton)
    }



    
    @objc func buttonTapped(sender: AnyObject) {
        self.dismiss(animated: true, completion: nil)
    }

        
繰り返し for
for i in 0...14 {
    // 処理
}

ログ、print 
 // 列のセルのdeleteCheckFlgが全てtrueの場合、その列は映さない
            print("--------------------------------------------------")
            print(self.provider.cellItems.count)
            print("--------------------------------------------------")


textViewの文字数制限
func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {

    let currentText = textView.text ?? ""
    guard let stringRange = Range(range, in: currentText) else { return false }
    let changedText = currentText.replacingCharacters(in: stringRange, with: text)
    return changedText.count <= 399 // Pass your character count here 
}



特定の文字列を指定して、そこから分割して配列にする
 guard let separateString = webView.url?.absoluteString.components(separatedBy: "=") else {
                print("Instagramのアクセストークンの取得に失敗")
                return
            }



URLのエラーを拾う（WKWebView）

func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation, withError error: Error) {
        
        handleError(error: error)
    }

func handleError(error: Error) {
        if let failingUrl = error.userInfo["NSErrorFailingURLStringKey"] as? String {
            
            print("-----------------failingUrl-------------------------")
           print(failingUrl)
            print("------------------failingUrl------------------------")

            setUrl(url: "https://qiita.com/peta-m175/items/102d6d723fd87e722f83")
            
            webView?.evaluateJavaScript("location.href=endLoading()", completionHandler: { (html, error) -> Void in
            
                print("実行完了")
            })
        }
    }

UISearchBar
seachBar

seachBar.delegate = self
// テキストフィールド内のクリアボタンを消す
if let textfield = recordSearchBar.value(forKey: "searchField") as? UITextField {
            textfield.clearButtonMode = .whileEditing
        }

// UISearchBarDelegate
// 検索ボタンタップ時
 func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        guard let searchWord = searchBar.text else {
            return
        }
        
        searchBar.setShowsCancelButton(false, animated: true)
        searchBar.resignFirstResponder()
//        recordSearchAPI.requestAPI(seachWord: searchWord)
    }
    
// 入力開始時
    func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
        searchBar.text = ""
        searchBar.setShowsCancelButton(true, animated: true)
    }
    
// キャンセルボタンタップ時
    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
        if searchBar.canResignFirstResponder {
            searchBar.setShowsCancelButton(false, animated: true)
            searchBar.resignFirstResponder()
        }
    }

通知関連（notification）
登録（基本コントローラーで登録して,deinitで削除）


 let notificationCenter = NotificationCenter.default
        notificationCenter.addObserver(self,
                                       selector: #selector(removePartnerIDFromSharedInstance(notification:)),
                                       name: .removePartnerIDFromSharedInstance,
                                       object: nil)

        setupPageViewController()
    }

    deinit {
        NotificationCenter.default.removeObserver(self, name: .removePartnerIDFromSharedInstance, object: nil)
    }


notificationトリガー
let notificationCenter = NotificationCenter.default
        notificationCenter.post(.init(name: Notification.Name("removePartnerIDFromSharedInstance")))
※ もしくわ
    static let removePartnerIDFromSharedInstance = Notification.Name("removePartnerIDFromSharedInstance")をexetensionで定義していれば
以下でいける
.removePartnerIDFromSharedInstance



通知（バックグラウンド処理）
        let center = NotificationCenter.default

//        center.addObserver(self,
//                           selector: #selector(self.didEnterBackground(notification:)),
//                           name: Notification.Name.UIApplicationDidEnterBackground,
//                           object: nil)

アクション	
//    @objc private func didEnterBackground(notification: Notification) {
//        print("didEnterBackground")
//        // バックグラウンドに入った時
//        self.schemeStart = false
//    }

クロージャの書き方（戻り値ない版）
メソッド側（この中の処理が終わったら〜する）
private func getProfileData(uuid: String, completionBlock: (() -> Void)? = nil) {}

呼ぶ側
getProfileData(uuid: uid, completionBlock: {
                    self.selectLibraryView.fadeInAnimation(type: .slow, completed: nil)
                })




web view URL追跡
//        // 表示中のWebページのURLを追跡
    var observeLoading: NSKeyValueObservation?


//                self.observeLoading = self.webView?.observe(\.url, options: [.new]) {_, change in
//                    guard let changeResult = change.newValue.unsafelyUnwrapped else {
//                        return
//                    }
//                    let urlString = changeResult.absoluteString
//
//                    // オンライン時
//                    UserDefaults.standard.set(urlString, forKey: "currentOpenURL")
//                }



URLからパラメータを取り出す属性を追加（URL["keyで取り出す"]）


定義と同時に値をセット
@IBOutlet private weak var addUserButton: UIButton! {
        didSet {
            addLayer(view: addUserButton,
                     corner: addUserButton.frame.width / 4.3,
                     borderColor: .black,
                     borderWidth: 0)
        }
    }


ランダムの文字列を作成
import UIKit
 
extension String {
    static func getRandomStringWithLength(length: Int) -> String {
        
        let alphabet = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        let upperBound = UInt32(alphabet.characters.count)
        
        return String((0..<length).map { _ -> Character in
//            return alphabet[alphabet.startIndex.advancedBy(Int(arc4random_uniform(upperBound)))]
            return alphabet[alphabet.index(alphabet.startIndex, offsetBy: Int(arc4random_uniform(upperBound)))]
        })
    }
}



navigationController 遷移カスタマイズ
 private func customTranstlation(navigationController: UINavigationController?) {
        let transition = CATransition()
        transition.duration = 1
        transition.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)
        transition.type = kCATransitionFade
        navigationController?.view.layer.add(transition, forKey: nil)
    }


セルクラスでレイアウトを足すタイミング
override func draw(_ rect: CGRect) {
        super.draw(rect)
        setLayer()
    }








if let decodeData = Data(base64Encoded: base64String, options: .ignoreUnknownCharacters) {
        yourWebView.load(decodeData, mimeType: "application/pdf", textEncodingName: "utf-8", baseURL: URL(fileURLWithPath: ""))
} // since you don't have url, only encoded String




dispatch main async
非同期処理の中で、メインスレッドの動作を指定したいときは、この表記の中でやる


didSetは、「そのプロパティに値が入った後に走るメソッド」


collectionView,TableView のスクロールを最後までは、
indexを指定して、そこまで移動にする（indexの数-1でわかる）


時間を指定して止める
DispatchQueue.main.asyncAfter(deadline: .now() + 秒数, execute: hanndolar)



なんかのイベントがあって、（input）
そのイベントでどうなるか？（output）（設計書）

クラス一覧（DB設定もいる）
クラス関連ず（矢印で処理順を書く）




ブレイクポイント

po url〜



URLの拡張子を取得
let path = NSString(string: "http://tecc0.com/index.html")
 
print(path.lastPathComponent) // index.html
print(path.pathExtension) // html


URLの先頭文字列のチェック
let hasHttp = requestURL.absoluteString.hasPrefix("http")


webviewで履歴から指定のページに遷移する
 let backPageCount = 2
        guard let urlHistory = webView?.backForwardList.backList else {
            print("閲覧履歴がありません。")
            self.view.window?.rootViewController?.dismiss(animated: true, completion: nil)
            return
        }
        setUrl(url: urlHistory[urlHistory.count - backPageCount].url.absoluteString)


Userdefoのデータはアプリ内の「Preferences」に入っている
キャッシュと同じ確認法


info.plistはcopybundle resoruseに入れない
合ったら、lintに怒られる

error型の文字列
error.localizedDescription



stringファイル使用

・stringクラスを拡張
extension String {

    func localized() -> String {
        return NSLocalizedString(self, comment: "")
    }
}

・stringファイル
// MARK: - Alert Button
"ALERT_OK" = "OK";

// MARK: - Message
"OFFLINE" = "通信環境の良い場所で再度お試しください。";
"TIMEOUT" = "タイムアウトになりました。";
"SESSION_IS_NIL" = "セッションが切れています。\n再度お試しください。";
"FAILED_TO_GET_TIMELINE" = "タイムラインの取得に失敗しました。";


・stringファイル作成後の呼び出し
"指定したキー".localized()



キーボードの上にボタン追加
 //キーボード上部に「完了」ボタンを追加（キーボード設定によりreturnキーがなくなっているため）
    private func addKey() {
        
        //デフォルトカラーを作成（ボタンの文字色用）
        let default_color1 = #colorLiteral(red: 0.07450980392, green: 0.5647058824, blue: 1, alpha: 1)
        let default_color2 = #colorLiteral(red: 0.07450980392, green: 0.5647058824, blue: 1, alpha: 0.3)
        
        // デバイスごとのスクリーン幅と高さを取得
        let screen_width = UIScreen.main.bounds.width
        let screen_height = UIScreen.main.bounds.height
        // ボタンを追加するためのViewを生成
        let onKeyboard = UIView(frame: CGRect(x: 0,
                                              y: 0,
                                              width: screen_width,
                                              height: screen_height / 14))
        // viewの色を指定
        onKeyboard.backgroundColor = UIColor.white
        
        // 完了ボタンの生成
        let btn = UIButton(frame: CGRect(x: screen_width-screen_width / 4,
                                         y: 0,
                                         width: screen_width / 4,
                                         height: screen_height / 14))
        //ボタンの背景を設定
        btn.backgroundColor = UIColor.white
        //ボタンのtitleを設定
        btn.setTitle("完了", for: .normal)
        //ボタンのフォントを設定
        btn.titleLabel?.font = UIFont.systemFont(ofSize: UIFont.main_text)
        //titleを中央寄せ
        btn.contentHorizontalAlignment = .center
        //押したときの色と押してない時の色を設定
        btn.setTitleColor(default_color1, for: .normal)
        btn.setTitleColor(default_color2, for: .highlighted)
        //ボタンをおした時の実行メソッドを設定
        btn.addTarget(self,
                      action: #selector(MainViewController.close_keyboard),
                      for: .touchUpInside)
        // viewへ完了ボタンを追加
        onKeyboard.addSubview(btn)
        //テキストフィールドにキーボード用のviewを追加
        totalfee_text.inputAccessoryView = onKeyboard
        people_text.inputAccessoryView = onKeyboard
    }


アラート　ヘルパー
import UIKit

final class AlertHelper {

    static func buildAlert(title: String = "",  // 初めから入れておくパターン
                           message: String,
                           rightButtonTitle: String = "ALERT_OK".localized(), // stringファイルから引っ張るパターン
                           leftButtonTitle: String? = nil, // 無いことにするパターン
                           rightButtonAction: ((UIAlertAction) -> Void)?, // アクションをセット
                           leftButtonAction: ((UIAlertAction) -> Void)? = nil) -> UIAlertController {

        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        let positiveAction = UIAlertAction(title: rightButtonTitle, style: .default, handler: rightButtonAction)
        alert.addAction(positiveAction)

        if let leftButtonTitle = leftButtonTitle {
            let negativeAction = UIAlertAction(title: leftButtonTitle, style: .cancel, handler: leftButtonAction)
            alert.addAction(negativeAction)
        }
        return alert
    }
}


info.plistをターゲットからコピーで追加した時は、右メニューの参照先が絶対パスになっているので、相対パスになおす（reratibegroup）



git操作
# GitHubへアップロードしたいプロジェクトディレクトリへ移動
$ cd /path/to/your/project
$ git init

# 必要であれば.gitignoreを作成し、バージョン管理しないファイルやディレクトリを記載（例：*.log）
$ vim .gitignore

# コミット 
$ git add .
$ git commit -m "Initial Commit"

# 先ほど作成したGitHubリポジトリのURLをコピー&ペーストして、リモートブランチとして設定
git remote add origin https://github.com/your-name/project-name.git

# push
git push -u origin master


ブランチの確認
ローカルブランチを確認する
git branch
リモートブランチを確認する
git branch -r
上記２つを一度に行う
git branch -a

差分の確認
git diff

現在のブランチから派生ブランチを作成する
git branch BN

作業ブランチを変更する
git checkout BN

上記２つを一度に行う
git checkout -b BN

Git強制チェックアウト
git checkout --force <ブランチ名>

現在の作業ブランチに指定ブランチをマージする
git merge BN
マージ後でも、元に戻せるようにする
git merge --no-ff BN
ブランチの削除
git branch -d BN
ブランチの削除(強制的)
git branch -D BN
リモート・リポジトリにブランチをプッシュする
git push origin BN
リモートブランチからローカルブランチを作成する
git checkout -b BN origin/BN
リモートリポジトリのブランチを取得して、ローカルブランチとする
git fetch origin RemoteBN:LocalBN
リモートブランチを削除する
git push origin :BN
ブランチの派生元ブランチを変更する
git rebase BN
ブランチを比較する
git diff BN1 BN2


通知（WillEnterForeground）
private func registeNotification() {
        let center = NotificationCenter.default
        center.addObserver(self,
                           selector: #selector(self.willEnterForeground(notification:)),
                           name: Notification.Name.UIApplicationWillEnterForeground,
                           object: nil)
    }
    
    @objc private func willEnterForeground(notification: Notification) {
       // アクション
    }

// 通知削除
    private func removeNotification() {
        let notificationCenter = NotificationCenter.default
        notificationCenter.removeObserver(self)
    }

暗号化データ→データの復号化（base64）
let newData = Data(base64Encoded: 暗号化データ(Data))

// アプリの状態を取得（バックグラウンドなど）
UIApplication.shared.applicationState


コードでWKwebViewのautolayout
 private func constainWebView(webView: WKWebView?) {
        webView?.translatesAutoresizingMaskIntoConstraints = false
        
        view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "H:|[v0]|",
                                                           options: NSLayoutFormatOptions(),
                                                           metrics: nil,
                                                           views: ["v0": webView ?? WKWebView()]))
        view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "V:|-20-[v0]|",
                                                           options: NSLayoutFormatOptions(),
                                                           metrics: nil,
                                                           views: ["v0": webView ?? WKWebView()]))
    }

jSの埋め込み
private func setJSAction() -> WKWebViewConfiguration {
        let jsString = "何かのスクリプト"
        
        let userScript = WKUserScript(source: jsString, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
        
        let wkUController = WKUserContentController()
        wkUController.addUserScript(userScript)
        
        let wkWebConfig = WKWebViewConfiguration()
        wkWebConfig.userContentController = wkUController
        
        return wkWebConfig
    }

呼び出すとステータスバーを作る（クラスごとに呼ぶ）
extension UIViewController {
    func setStatusBarBackgroundColor() {
        let statusBarBackground = UIView(frame: CGRect(x: 0,
                                                       y: 0,
                                                       width: self.view.bounds.width,
                                                       height: UIApplication.shared.statusBarFrame.height))
        statusBarBackground.backgroundColor = UIColor.black
        
        self.view.addSubview(statusBarBackground)
    }
}


パラメータをkeyで取り出せる
static func parameterDic(parameter: String) -> [String: String] {
        
        var parameters = [String: String]()
        let pairs = parameter.components(separatedBy: "&")
        
        for pair in pairs {
            let elements = pair.components(separatedBy: "=")
            let key = elements[0].removingPercentEncoding
            let value = elements[1].removingPercentEncoding
            
            if let key = key, let value = value {
                parameters[key] = value
            }
        }
        return parameters
    }


テストコードの比較式
https://qiita.com/shirochan/items/10271912289dc563cc36


ページ間の値受け渡し
// 受け取る側に以下を設定
// MARK: - Factory
    class func make(url: String) -> DetailViewController {
        let storyboard = UIStoryboard(name: DetailViewController.identifer, bundle: nil)
        guard let detailViewControllerVC = storyboard.instantiateViewController(withIdentifier: DetailViewController.identifer) as? DetailViewController else {
            fatalError("VCのインスタンス化に失敗")
        }
        detailViewControllerVC.accessURL = url
        return detailViewControllerVC
    }


// 遷移側
let detailVC = DetailViewController.make(url: provider.accessList[indexPath.row].url)
self.navigationController?.pushViewController(detailVC, animated: true)


バージョンごと
if #available(iOS 10.0, *) {
                // iOS10以降の場合
            } else {
                // iOS9以前の場合
            }


メインスレッドで実行（非同期中にかく）
DispatchQueue.main.async {
        // Main Threadで実行することをかく
    }


クロージャー
ハンドラー
completion: (()-> Void)?
引数あり（_を入れることで引数名の表示は省略される）
completion: @escaping ((_ restData: [RestData], _ error: Error?) -> ())
デフォルト引数あり（引数入力自体を省略できる）
completionHandler: ((Any) -> ())? = nil

日付
Date変換

//MARK: - Helper
    /// 文字列⇒日付変換
    ///
    /// - Parameter dateString: 日付（文字列）
    /// - Returns: 日付
    private func stringToDate(dateString: String) -> Date {
        let dateFormater = DateFormatter()
        dateFormater.locale = Locale(identifier: "ja_JP")
        dateFormater.dateFormat = "yyyy/MM/dd HH:mm:ss"
        return dateFormater.date(from: dateString) ?? Date()
    }
    
    /// 日付⇒文字列変換
    ///
    /// - Parameter date: 日付
    /// - Returns: 日付（文字列）
    private func dateToString(date: Date) -> String {
        let dateFormater = DateFormatter()
        dateFormater.locale = Locale(identifier: "ja_JP")
        dateFormater.dateFormat = "yyyy/MM/dd HH:mm:ss"
        return dateFormater.string(from: Date())
    }


// Error側をNSErrorも使えるように拡張
extension Error {
    fileprivate var nsError: NSError {
        return (self as NSError)
    }
}

ストリングファイルの使用
まず以下のURLに沿ってstrigfileを作る
https://qiita.com/simorgh3196/items/c9b04377dfa1425085c3

stringを拡張するクラスを用意
ローカライズ
クラス名：String+Localized

import Foundation

extension String {

    func localized() -> String {
        return NSLocalizedString(self, comment: "")
    }

}

使用法
呼び出す場所で
"stringfileでのkey".localized()

stringファイル内
"offlineAlertTitle" = "警告";

変数の型の種別を知る
targetView.isKind(of: 任意の型.self)
