toolBarの使い方
NavigationView {
            Group {
            List {
                ForEach(items) { item in
                    Text("Item at \(item.timestamp!, formatter: itemFormatter)")
                }
                .onDelete(perform: deleteItems)
            }

            }
            .navigationTitle("Repositories")
            .toolbar(content: {
                ToolbarItem(placement: .navigationBarTrailing){
                    Button(action: {}) {
                        Image(systemName: "square.and.arrow.up")
                    }
                }
                ToolbarItem(placement: .navigationBarLeading){
                    Button(action: {}) {
                        Image(systemName: "cart")
                    }
                }
                // placementで色々な表示方法を選べる
                ToolbarItem(placement: .navigation){
                    Button(action: {}) {
                        Image(systemName: "yensign.square")
                    }
                }

                // カスタムで作る場合(bottomBarでは自由度が少ないからカスタムでやっても良い)
                ToolbarItemGroup(placement: .bottomBar) {
                    Button(action: {}) {
                        Image(systemName: "arrow.uturn.backward")
                    }
                    Spacer()
                    Text("操作")
                    Spacer()
                    Button(action: {}) {
                        Image(systemName: "arrow.uturn.forward")
                    }
                }

            })
        }



AnyPublishの作り方
Just・・・同期的に値を返せる、エラーは発行できない
Future・・・非同期的に値を返せる、エラーも発行できる

処理前に通る
.handleEvents(receiveSubscription: { [weak self] _ in
                self?.repos = .loading
            })
以降の処理をスレッド切り替え
.receive(on: DispatchQueue.main)

protocolはObservableObjecttoshite@StateObjectで監視対象にできないらしい

Publisherと普通の関数を繋げる場合はmap、PublisherとPublisherを繋げる場合はflatMapを使います。
https://zenn.dev/ryotapoi/articles/7dba6606f8e80b8f65d8


遅延実行
func ddd(array: [PublicRepository]) -> AnyPublisher<[Repo], Error> {
        return Deferred { //Deferred 宣言時には走らない、sbscribe時に初めて走る
            Future<[Repo], Error> { (promise) in
                DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                    let dd = array.map {
                        Repo(id: $0.id,
                             name: $0.name,
                             owner: User(name: $0.owner.login),
                             description: $0.description ?? "",
                             stargazersCount: $0.stargazersCount)
                    }
                    promise(.success(dd))}
            }
        }
        .eraseToAnyPublisher()
    }




ViewDidLoad -> onAppear

ボタン太字
.fontWeight(.bold)

@StateObject
combineでバイディンングするクラスにつける(viewmodelと繋ぐ)

@Published
監視するプロパティにつける（UIとバインディングしている証拠なのでメインスレッドで触ること）

@State
バインディング用のプロパティラッパー
これつけていれば、変更が会った時にbodyを再発火できる

テーブルViewのセクション作る
List {
            Section(header: Text("Meeting Info")) {
            }
        }

TextField（TitleはPlacefolder、scrumData.titleはバインディングする値）
TextField("Title", text: $scrumData.title)

これだけでカラーピッカー出せる
ColorPicker("Color", selection: $scrumData.color)

ForEachでテーブル表示した値への削除アクションの定義
ForEach(scrumData.attendees, id: \.self) { attendee in
                    Text(attendee)
                }
                .onDelete { indices in
                    scrumData.attendees.remove(atOffsets: indices)
                }

プラスボタン
Button(action: {}) {
                        Image(systemName: "plus.circle.fill")
                    }

このBOOL値が変更になったら、画面遷移(full)で発動、どのViewを返すかはクロージャないで（Viewに対するオプション）
.fullScreenCover(isPresented: $isPresented) {
            EditView()
        }

NavigationView で囲むとナビバー特定を与えられる（titleとか設定できる、遷移はshowには変わらない）

EditViewにナビバーとbarbuttonitemつけている
NavigationView {
                EditView()
                    .navigationTitle(scrum.title)
                    .navigationBarItems(leading: Button("Cancel") {
                        isPresented = false
                    }, trailing: Button("Done") {
                        isPresented = false
                    })
            }

スライダー（5~30を5刻みで選択可能）
Slider(value: $scrumData.lengthInMinutes, in: 5...30, step: 5.0) {
                        Text("Length")
                    }

ボタンにかかるオプション（非活性、この場合はstringが空、指定したBOOL値でバインドされる、@Stateはいらないっっぽい）
.disabled(newAttendee.isEmpty)


アニメーション付きテーブル追加
withAnimation {
                            scrumData.attendees.append(newAttendee)
                        }

これの挙動がわからん
.font(.caption)


プレビューをフリーサイズで表示できる
.previewLayout(.fixed(width: 400, height: 60))


グラデーションの色作る
LinearGradientを使う
static let gradientStart = Color(red: 239.0 / 255, green: 120.0 / 255, blue: 221.0 / 255)
    static let gradientEnd = Color(red: 239.0 / 255, green: 172.0 / 255, blue: 120.0 / 255)

~~.fill(LinearGradient(
                            gradient: .init(colors: [Self.gradientStart, Self.gradientEnd]),
                            startPoint: .init(x: 0.5, y: 0),
                            endPoint: .init(x: 0.5, y: 0.6)
                        ))
レイヤーのアスペクト比をviewに合わせる
.aspectRatio(1, contentMode: .fit)


Viewに線を引く
Pathを使う
HexagonParameters.pointsに定義した線座標をつなげて、多角形を描く（中身は黒色）
move、addLineで表示、addQuadCurveで角丸
Path { path in
            var width: CGFloat = 100.0
            let height = width
            path.move(to: CGPoint(x: width * 0.95, y: height * 0.20))
            HexagonParameters.points.forEach {
                path.addLine(
                    to: .init(
                        x: width * $0.useWidth.0 * $0.xFactors.0,
                        y: height * $0.useHeight.0 * $0.yFactors.0
                    )
                )
            }
        }
        .fill(Color.black)

@EnvironmentObjectをつけるとViewクラス全体で共通のプロパティとなります。（View内部のshardなpropatyになる）
@EnvironmentObject var userData: UserData

@Environmentは初期値の設定を初期化時に行えるvar変数、letではなくvarで宣言できるので変数として扱える


@Stateを頭につけると変数が変更可能になる mutableになる、基本はSwiftUIのViewは変更不可能
@State var showFavoritesOnly = false


変数とのバインディングは頭に$をつける
$showFavoritesOnly
例
// スイッチタイプのセル生成
Toggle(isOn: $showFavoritesOnly) {
                    Text("Favorites only")
                }


// landmarkDataの要素(Landmark)をlistで並べる（idプロパティをkeyに取得するようにしている）
List(landmarkData, id: \.id) {}

↑はLandmarkクラスがIdentifiableプロトコルに準拠していれば、どのkeyで取得するかの指定はいらない
List(landmarkData) {}

プレビューpreviewできる端末のリストをターミナルで取得
xcrun simctl list devicetypes


static var previews: some View {
        Group { // 複数端末でpreview見る
            LandmarkList()
                .previewDevice(PreviewDevice(rawValue: "iPhone SE"))
                .previewDisplayName("iPhone SE")
            LandmarkList()
                .previewDevice(PreviewDevice(rawValue: "iPhone XS Max"))
                .previewDisplayName("iPhone XS Max")
        }
    }

パターン2

static var previews: some View {
        Group {
            ForEach(["iPhone SE", "iPhone Xs Max"], id: \.self) { deviceName in
                Wrapper()
                    .previewDevice(PreviewDevice(rawValue: deviceName))
                    .previewDisplayName(deviceName)
            }
        }
    }

for文で回してpreview端末増やす
ForEach(["iPhone SE", "iPhone XS Max"], id: \.self) { deviceName in
                LandmarkList()
                    .previewDevice(PreviewDevice(rawValue: deviceName))
                    .previewDisplayName(deviceName)
            }